%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{FOBOS 2.0}
\date{Nov 04, 2019}
\release{2.0}
\author{Abubakr Abdulgadir, William Diehl and Jens-Peter Kaps}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


The Flexible Opensource workBench fOr Side-channel analysis FOBOS is a platform to perform side-channel analysis (SCA).
FOBOS uses commercially avilable boards when possible to reduce the cost of building a working SCA setup.
Using FOBOS, power traces can be collected and attacks like Correlation Power Analysis (CPA) can be mounted.
Also, scripts to perform leakage assesment are included.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=350\sphinxpxdimen]{{fobos2}.jpg}
\caption{Typical FOBOS2 Setup}\label{\detokenize{index:id1}}\end{figure}


\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}
The Flexible Opensource workBench fOr Sidechannel analysis (FOBOS) is a platform that
can be used for side channel analysis.
You can perform trace collection (Data Acquisition) and attacks (Data Analysis).
The system is suitable for educational and research purposes.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fobos2-block}.png}
\caption{FOBOS Block Diagram}\label{\detokenize{introduction:id1}}\end{figure}


\section{Feature Overview}
\label{\detokenize{introduction:feature-overview}}\begin{itemize}
\item {} 
Separate control and (Design Under Test) boards allowing addition of new DUTs easily.

\item {} 
Uses commercial over-the-shelf boards when possible to reduce cost.

\item {} 
Digilent Basys3 and Nexys A7 control boards.

\item {} 
DUT support includes Digilent Nexys3 board (Xilinx Spartan6) and compatible with NewAE CW305
(Xilinx Artix7 boards).

\item {} 
Adjustable DUT clock.

\item {} 
Adjustable trigger signal.

\item {} 
Software to perform Correlation Power Analysis (CPA).

\item {} 
Leakage assessment using t-test and chi-squared test.

\end{itemize}


\chapter{Setup}
\label{\detokenize{setup:setup}}\label{\detokenize{setup::doc}}
Below, we describe how to setup FOBOS 2.0 hardware and software and test that everything is working.
This page only describes setting up the control board and software for acquisition and anlysis.
For DUT board please refer to {\hyperref[\detokenize{dut_board_setup:dut-board-setup-label}]{\sphinxcrossref{\DUrole{std,std-ref}{DUT Board Setup}}}}.


\section{Requirements}
\label{\detokenize{setup:requirements}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Digilent Basys3 board (control board).

\item {} 
A PC with Linux installed.

\item {} 
Python2.7 installed.

\item {} 
Xilinx Vivado 2017.2.

\item {} 
Picoscope 5000 series.

\end{enumerate}


\section{Software Setup}
\label{\detokenize{setup:software-setup}}
Note: The following installation procedure is tested on Linux Ubuntu 16.04.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Download FOBOS from the \sphinxhref{https://cryptography.gmu.edu/fobos/getfobos.php}{FOBOS home page}.

\item {} 
Extract the archive into the directory of your choice

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} tar xvfz fobos\PYGZhy{}v2.0.tgz
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Use the following commands to install pip and few necessary Python packages:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} sudo apt\PYGZhy{}get install python\PYGZhy{}pip
\PYGZdl{} tar xvfz fobos\PYGZhy{}v2.0.tgz
\PYGZdl{} pip isnatll \PYGZhy{}r requirements.txt
\end{sphinxVerbatim}


\section{Control board Setup}
\label{\detokenize{setup:control-board-setup}}
Follow these steps to compile the control software, generate the bitstream and program
the the control board.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Build the control board Vivado project.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{cd} fobos/capture/ctrl/basys3ctrl/vivado
\PYGZdl{} make project
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
A Vivado project will be created at fobos/capture/ctrl/basys3ctrl/vivado/basys3ctrl. Open it using Vivado.

\end{enumerate}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{open_project}.png}
\caption{Open Vivado project}\label{\detokenize{setup:id1}}\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
In Vivado’s Flow Navigator window, click ‘Generate Bitstream’.

\item {} 
After bitstream is generated, export the hardware. Click File \textgreater{} Export \textgreater{} Export Hardware … make sure to select ‘Include bitstream’.

\end{enumerate}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{export_hardware}.png}
\caption{Export Hardware}\label{\detokenize{setup:id2}}\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
Launch the Xilinx SDK (File \textgreater{} Launch SDK).

\end{enumerate}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{launch_sdk}.png}
\caption{Launch SDK}\label{\detokenize{setup:id3}}\end{figure}

6. In the SDK, create a new empty project(File\textgreater{} New application project). Set the project name to \sphinxstyleemphasis{ctrl} and select
the hardware platform, click Next and make sure you select ‘Empty project’.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{create_sdk_app}.png}
\caption{Create Project}\label{\detokenize{setup:id4}}\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
Link all the .c and .h files in the fobos/capture/ctrl/basys3ctrl/sdk/src/ to the project
(right-click on ctrl/src folder -\textgreater{} Import -\textgreater{} General-\textgreater{} file system -\textgreater{} browse to folder).
make sure to check “Advanced-\textgreater{} Create links in the workspace” and “Create virtual folders” .

\end{enumerate}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{import_sdk_src}.png}
\caption{Launch SDK}\label{\detokenize{setup:id5}}\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
Program the control borad FPGA. Connect the Basys3 board to your PC via USB. In the Xilinx Tools menu, select Program FPGA -\textgreater{} program.

\item {} 
Run the control software. Make sure to select the \sphinxstyleemphasis{ctrl} project created in step 6 then go to the Run menu and select ‘Run’.

\item {} 
You should see the word CERG in the seven-segment display of the Basys3 board.

\end{enumerate}


\section{Testing the control board}
\label{\detokenize{setup:testing-the-control-board}}
To make sure the control board is working, you can run the \sphinxstyleemphasis{dymmyCaptureBasic.py} script in the fobos/software directory.
This script send data to the board wich echos data back.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd path\PYGZhy{}to\PYGZhy{}fobos/software
\PYGZdl{} python dummyCaptureBasic.py
Sending configuration...
f0030006000900000001
Status= 00000000
f0030006000000000007
Status= 00000000
Sending data..
f001001e00c0000761996dc996d4ac00c100070f7821507a22a00081000700800001
OK.    Status= 00000000
61 99 6d c9 96 d4 ac
f001001e00c00007fd8771fe717de400c100073e1fe5b4aa357c0081000700800001
OK.    Status= 00000000
fd 87 71 fe 71 7d e4
f001001e00c0000782051f5484702200c10007980d05d4ea25bc0081000700800001
OK.    Status= 00000000
82 05 1f 54 84 70 22
f001001e00c0000767881b702afe5200c10007b08a5e036de72b0081000700800001
OK.    Status= 00000000
67 88 1b 70 2a fe 52
f001001e00c0000726a1d601ccdf7a00c1000773539e52672d5d0081000700800001
OK.    Status= 00000000
26 a1 d6 01 cc df 7a
\end{sphinxVerbatim}

If you see this output, your control board is now ready!


\chapter{Test Vector Generation}
\label{\detokenize{tvgen:test-vector-generation}}\label{\detokenize{tvgen:tvgen-label}}\label{\detokenize{tvgen::doc}}
The user must prepare test vectors before running data acquisition. User defined scripts or scripts provided with FOBOS can be used.
The data acquisition scripts will send the test vectors one at a time and collect traces from the oscilloscope.

Cryptographic hardware interfaces typically use multiple data types as input to cryptographic cores.
For example, some algorithms might need plaintext/ciphertext, cryptographic keys, and random data.
We provide a simple wrapper to split data provided by the control board to separate streams.
This wrapper is directly compatible with CAESAR Hardware API interface and is expected to be directly compatible with a future Hardware API for Lightweight Cryptography (LWC API).
We developed a simple, yet versatile protocol to enable the wrapper to split the data types.
The wrapper receives data from the control board and distributes it into three FIFOs:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The Public Data Input (PDI) FIFO (i.e. plaintext)

\item {} 
The Secret Data Input (SDI) FIFO (i.e. key)

\item {} 
The Random Data Input (RDI) FIFO which stores random data which can be used for protected implementations that use masking schemes.

\end{enumerate}

Once the wrapper prepares the data for the function core, it starts the core which consumes the data in the input FIFOs and produces output.
The wrapper accumulates the output into a fourth FIFO called the Data Out (DO) FIFO until the expected number of bytes are stored.
Then, the wrapper returns the data to the control board which forwards it back to the PC.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{fobos2-block}.png}
\caption{FOBOS2 block diagram}\label{\detokenize{tvgen:id1}}\end{figure}

The following is a brief description for the test vector format


\section{Supported commands}
\label{\detokenize{tvgen:supported-commands}}\begin{itemize}
\item {} 
00C0 \# pdi fifo (length in bytes to follow)

\item {} 
00C1 \# sdi fifo (length in bytes to follow)

\item {} 
00C2 \# rdi fifo (length in bytes to follow)

\item {} 
0081 \# store expected output size (expected output size in bytes to follow)

\item {} 
0080 \# select command register (command to follow)

\end{itemize}


\subsection{FOBOS Protocol Example}
\label{\detokenize{tvgen:fobos-protocol-example}}
Here is an example of a signle test vector(split into multiple lines):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{00}\PYG{n}{C0} \PYG{c+c1}{\PYGZsh{} pdi fifo (length in bytes to follow)}
\PYG{l+m+mi}{0008} \PYG{c+c1}{\PYGZsh{} 8 bytes}
\PYG{n}{FFFF} \PYG{c+c1}{\PYGZsh{} 8 bytes of pdi}
\PYG{n}{FFFF}
\PYG{n}{FFFF}
\PYG{n}{FFFF}
\PYG{l+m+mi}{00}\PYG{n}{C1} \PYG{c+c1}{\PYGZsh{} sdi fifo (length in bytes to follow)}
\PYG{l+m+mi}{000}\PYG{n}{A} \PYG{c+c1}{\PYGZsh{} 10 bytes}
\PYG{l+m+mi}{0000} \PYG{c+c1}{\PYGZsh{} 10 bytes of sdi}
\PYG{l+m+mi}{0000}
\PYG{l+m+mi}{0000}
\PYG{l+m+mi}{0000}
\PYG{l+m+mi}{0000}
\PYG{l+m+mi}{0081} \PYG{c+c1}{\PYGZsh{} store expected output size}
\PYG{l+m+mi}{0008} \PYG{c+c1}{\PYGZsh{} 8 bytes of output expected}
\PYG{l+m+mi}{0080} \PYG{c+c1}{\PYGZsh{} select command register}
\PYG{l+m+mi}{0001} \PYG{c+c1}{\PYGZsh{} \PYGZdq{}start signal\PYGZdq{}}
\end{sphinxVerbatim}


\section{Using the blockCipherTVGen.py script}
\label{\detokenize{tvgen:using-the-blockciphertvgen-py-script}}
The blockCipherTVGen.py can be used to generate test vectors to be used by block ciphers. The script is located at fobos/software/tvgen/
There are two steps to use it:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Set user defined parameters.

\item {} 
Run the script. It will generate the test vector file and plaintext file (not required for acquisition).

\end{enumerate}


\subsection{Example: Generating AES-128 test vectors}
\label{\detokenize{tvgen:example-generating-aes-128-test-vectors}}
AES-128 takes 16 bytes (128 bits) plaintext, 16 key and returns 16 byte ciphertext.
Here is an example to generate 4 test vectors with 16 byte blocks, key and ciphertext. Key is fixed in this case.

Settings:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}user defined settings}
\PYG{n}{TRACE\PYGZus{}NUM} \PYG{o}{=} \PYG{l+m+mi}{1000}                           \PYG{c+c1}{\PYGZsh{} Number of traces}
\PYG{n}{PDI\PYGZus{}LENGTH} \PYG{o}{=} \PYG{l+m+mi}{16}                            \PYG{c+c1}{\PYGZsh{} In byets}
\PYG{n}{SDI\PYGZus{}LENGTH} \PYG{o}{=} \PYG{l+m+mi}{16}                            \PYG{c+c1}{\PYGZsh{} In bytes}
\PYG{n}{EXPECTED\PYGZus{}OUT} \PYG{o}{=} \PYG{l+m+mi}{16}                          \PYG{c+c1}{\PYGZsh{} Expected output in bytes}
\PYG{n}{DIN\PYGZus{}FILE} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dinFile.txt}\PYG{l+s+s1}{\PYGZsq{}}                   \PYG{c+c1}{\PYGZsh{} Desitination file name}
\PYG{n}{PLAINTEXT\PYGZus{}FILE} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plaintext.txt}\PYG{l+s+s1}{\PYGZsq{}}           \PYG{c+c1}{\PYGZsh{} Desitination file name}
\PYG{n}{FIXED\PYGZus{}KEY} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}                          \PYG{c+c1}{\PYGZsh{} Fixed key = yes \textbar{} no}
\PYG{n}{KEY} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{123456789009876ABCDFE12456789ABF}\PYG{l+s+s1}{\PYGZsq{}}   \PYG{c+c1}{\PYGZsh{} Fixed key}
\end{sphinxVerbatim}

To run the script, use the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python blockCipherTVGen.py
\end{sphinxVerbatim}

Here is how the generated dinFile.txt looks like.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cat dinFile.txt
00C000103AD5305EBD0C99C7482263E2D7ECEAED00C1001012345...0081001000800001
00C000105C09504D713BF9B5925601E671EA257800C1001012345...0081001000800001
00C00010A6D6DE2548E4CCF446ECA8E620E4E55500C1001012345...0081001000800001
00C00010E0792CDE9AFDA7EAC33A8D0EADE524CB00C1001012345...0081001000800001
00C000104A09A00A4C4268F0B6F4FCE4F514A6BB00C1001012345...0081001000800001
\end{sphinxVerbatim}

This file can now be used in FOBOS as a test vector file.

A plaintext.txt file is also generated, it includes only the PDI portion dinFile.txt:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cat plaintext.txt
3A D5 30 5E BD 0C 99 C7 48 22 63 E2 D7 EC EA ED
5C 09 50 4D 71 3B F9 B5 92 56 01 E6 71 EA 25 78
A6 D6 DE 25 48 E4 CC F4 46 EC A8 E6 20 E4 E5 55
E0 79 2C DE 9A FD A7 EA C3 3A 8D 0E AD E5 24 CB
4A 09 A0 0A 4C 42 68 F0 B6 F4 FC E4 F5 14 A6 BB
\end{sphinxVerbatim}

This file can be used later by the analysis module.


\chapter{DUT Board Setup}
\label{\detokenize{dut_board_setup:dut-board-setup}}\label{\detokenize{dut_board_setup:dut-board-setup-label}}\label{\detokenize{dut_board_setup::doc}}
A DUT (Design Under Test) board must be connected to the control board to run SCA. Here,
we show how to connect and (modify board if needed) so that it can be used in FOBOS.


\section{Digilent Nexy3 (Spartan 6 FPGA)}
\label{\detokenize{dut_board_setup:digilent-nexy3-spartan-6-fpga}}

\subsection{Connection to Basys3 control board}
\label{\detokenize{dut_board_setup:connection-to-basys3-control-board}}
The PMOD ports on both boards are used to transfer data. The ports should be connected as follows
\begin{itemize}
\item {} 
Basys3 JA -\textgreater{} Nexys3 JC

\item {} 
Basys3 JXADC -\textgreater{} Nexys3 JD

\end{itemize}

The connector must connect each pin to its corresponding pin in the other board. The GND of the two
ports must be connected, However, the Vcc SHOULD NOT be connected.

The pin mapping in the Nexys3 DUT is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}JC}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}  din3    \textbar{}  do\PYGZus{}ready\textbar{}  rst     \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}          \textbar{}          \textbar{}          \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  din0    \textbar{}  din2    \textbar{}  din1    \textbar{}  do\PYGZus{}valid\textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}          \textbar{}          \textbar{}          \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{c+c1}{\PYGZsh{}JD}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  dout1   \textbar{}  dout3   \textbar{}  di\PYGZus{}ready\textbar{}  clk     \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}          \textbar{}          \textbar{}          \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  dout0   \textbar{}  dout2   \textbar{}  di\PYGZus{}valid\textbar{}          \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}          \textbar{}          \textbar{}          \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\end{sphinxVerbatim}

The pin mapping in the Basys3 control board is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}JA}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}  din3    \textbar{}  do\PYGZus{}ready\textbar{}  rst \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  G2      \textbar{}  J2      \textbar{}  L2      \textbar{}  J1      \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  din0    \textbar{}  din2    \textbar{}  din1    \textbar{}  do\PYGZus{}valid\textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  G3      \textbar{}  H2      \textbar{}  K2      \textbar{}  H1      \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{c+c1}{\PYGZsh{}JXADC}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  dout1   \textbar{}  dout3   \textbar{}  di\PYGZus{}ready\textbar{}  dut\PYGZus{}clk     \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  N2      \textbar{}  M2      \textbar{}  L3      \textbar{}  J3      \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  dout0   \textbar{}  dout2   \textbar{}  di\PYGZus{}valid\textbar{}          \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  N1      \textbar{}  M1      \textbar{}  M3      \textbar{}  K3      \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\end{sphinxVerbatim}


\subsection{Board modification}
\label{\detokenize{dut_board_setup:board-modification}}\begin{itemize}
\item {} 
To make perfoming SCA attacks easier, all capacitors on the FPGA core voltage rail have been removed.

\item {} 
The board is modified to be able to access the FPGA core voltage rail.

\item {} 
To measere power, an inductive power porbe may be used (e.g. Tektronix CT-1).

\end{itemize}


\section{NewAE CW305 (Artix7 FPGA)}
\label{\detokenize{dut_board_setup:newae-cw305-artix7-fpga}}
The PMOD ports JA and JXADC in the Basys3 control board should be connected to 40-pin port JP3.
The pin mapping in the NewAE CW305 is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}JP3}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}  din3    \textbar{}  do\PYGZus{}ready\textbar{}  rst     \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  NC      \textbar{}  D16     \textbar{}  E16     \textbar{}  F12     \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  din0    \textbar{}  din2    \textbar{}  din1    \textbar{}  do\PYGZus{}valid\textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  D15     \textbar{}  E15     \textbar{}  E13     \textbar{}  F15     \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  dout1   \textbar{}  dout3   \textbar{}  di\PYGZus{}ready\textbar{}  clk     \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  B12     \textbar{}  A13     \textbar{}  B15     \textbar{}  C11     \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  dout0   \textbar{}  dout2   \textbar{}  di\PYGZus{}valid\textbar{}          \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  A12     \textbar{}  A14     \textbar{}  A15     \textbar{}  C12     \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\end{sphinxVerbatim}

To measure the power, you can connect your oscilloscope to test poin X4. For more information,
refer to the manufacturer web-site.


\chapter{DUT Algorithm Development}
\label{\detokenize{dutdev:dut-algorithm-development}}\label{\detokenize{dutdev::doc}}
This document describes how to interface the DUT wrapper and the Function Core (victim).
The  Function Core (a.k.a victim), is the algorithm to be tested. The DUT wrapper is hardware that is instantaited on the same
FPGA as the function core and used to communication to the control board.
The function core is user provided. However, the DUT wrapper is included with FOBOS.
The DUT Wrapper handles communication to the control board and includes FIFOs to store input and output data.


\section{Data flow description:}
\label{\detokenize{dutdev:data-flow-description}}
Test vectors are sent form PC one at a time to the control board which stores them breifly.
The control board starts sending the test vector to the DUT board through the interface described below.
The DUT wrapper then puts data in the correct FIFOs (PDI, SDI and RDI).
Once the DUT wrapper receives the start command from the controller, it de-assersts the function core reset signal and the function core will run and consume the data in the FIFOs.
The output of the function core is stored in the DO fifo.
Once the DO FIFO accumulates EXPECTED\_OUTPUT bytes, the DUT wrapper will send this data to the control board which forwards it to the PC.


\section{The DUT Wrapper \textless{}\textendash{}\textgreater{} Function core interface}
\label{\detokenize{dutdev:the-dut-wrapper-function-core-interface}}
The protocol follows a simple AXI stream protocol. The ‘valid’ signals indicates data from source are valid and ‘ready’ signals
indicates destination is ready to use data. When both ‘valid’ and ‘ready’ signals are set to logic 1, data is transfered.
All the data signals shown in the listing below, are connected to the FIFOs PDI, SDI, RDI and DO.

The function core (victim) is instantiated as follows in the FOBOS\_DUT.vhd file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{victim}\PYG{o}{:} \PYG{k}{entity} \PYG{n+nc}{work}\PYG{p}{.}\PYG{n}{victim}\PYG{p}{(}\PYG{n}{behav}\PYG{p}{)}
    \PYG{c+c1}{\PYGZhy{}\PYGZhy{} Choices for W and SW are independently any multiple of 4, defined in generics above}
    \PYG{k}{generic} \PYG{k}{map}  \PYG{p}{(}
        \PYG{n}{G\PYGZus{}W}          \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{W}\PYG{p}{,} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} ! pdi and do width (mulltiple of 4)}
        \PYG{n}{G\PYGZus{}SW}         \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{SW} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} ! sdi width (multiple of 4)}
    \PYG{p}{)}
    \PYG{k}{port} \PYG{k}{map}\PYG{p}{(}
        \PYG{n}{clk} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{clk}\PYG{p}{,}
        \PYG{n}{rst} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{,}
        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} data signals}
        \PYG{n}{pdi\PYGZus{}data}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{pdi\PYGZus{}data}\PYG{p}{,}
        \PYG{n}{pdi\PYGZus{}valid} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{pdi\PYGZus{}valid}\PYG{p}{,}
        \PYG{n}{pdi\PYGZus{}ready} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{pdi\PYGZus{}ready}\PYG{p}{,}
        \PYG{n}{sdi\PYGZus{}data} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sdi\PYGZus{}data}\PYG{p}{,}
        \PYG{n}{sdi\PYGZus{}valid} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sdi\PYGZus{}valid}\PYG{p}{,}
        \PYG{n}{sdi\PYGZus{}ready} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sdi\PYGZus{}ready}\PYG{p}{,}
        \PYG{n}{do\PYGZus{}data} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{result\PYGZus{}data}\PYG{p}{,}
        \PYG{n}{do\PYGZus{}ready} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{result\PYGZus{}ready}\PYG{p}{,}
        \PYG{n}{do\PYGZus{}valid} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{result\PYGZus{}valid}

    \PYG{c+c1}{\PYGZhy{}\PYGZhy{}  ! if rdi\PYGZus{}interface for side\PYGZhy{}channel protected versions is required,}
    \PYG{c+c1}{\PYGZhy{}\PYGZhy{}  ! uncomment the rdi interface}
    \PYG{c+c1}{\PYGZhy{}\PYGZhy{}  ,rdi\PYGZus{}data =\PYGZgt{} rdi\PYGZus{}data,}
    \PYG{c+c1}{\PYGZhy{}\PYGZhy{}  rdi\PYGZus{}ready =\PYGZgt{} rdi\PYGZus{}ready,}
    \PYG{c+c1}{\PYGZhy{}\PYGZhy{}  rdi\PYGZus{}valid =\PYGZgt{} rdi\PYGZus{}valid}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The generic W is the PDI and DO width in bits.
The generic SW is the SDI width.

It is highly recommended that the DUT is tested using the capture/dut/fpga\_dut/fobos\_dut\_tb.vhd test bench and ensure
that the output is valid.
This testbench needs one test vector to be stored in the file dinFile.txt and generates doutFile.txt output file.


\section{Dummy DUT Example}
\label{\detokenize{dutdev:dummy-dut-example}}
You can find an example dummy DUT in fobos/capture/dut/example\_cores/dummy1.
This dummy core is used to test FOBOS DUT.
It simply echos back configurable number of words of the PDI sent in the test vector.
The dummy core in the listing below, echos seven 8-bit words of the PDI from the test vector received from the DUT wrapper.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{IEEE}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{IEEE.STD\PYGZus{}LOGIC\PYGZus{}1164.}\PYG{k}{ALL}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{entity} \PYG{n+nc}{dummy} \PYG{k}{is}
    \PYG{k}{Generic}\PYG{p}{(}
        \PYG{n}{N}        \PYG{o}{:} \PYG{k+kt}{integer} \PYG{o}{:}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{;}
        \PYG{n}{NUMWORDS} \PYG{o}{:} \PYG{k+kt}{integer} \PYG{o}{:}\PYG{o}{=} \PYG{l+m+mi}{7}
    \PYG{p}{)}\PYG{p}{;}
    \PYG{k}{port}\PYG{p}{(}\PYG{n}{clk}       \PYG{o}{:} \PYG{k}{in}  \PYG{k+kt}{STD\PYGZus{}LOGIC}\PYG{p}{;}
         \PYG{n}{rst}       \PYG{o}{:} \PYG{k}{in}  \PYG{k+kt}{STD\PYGZus{}LOGIC}\PYG{p}{;}
         \PYG{n}{pdi\PYGZus{}data}  \PYG{o}{:} \PYG{k}{in}  \PYG{k+kt}{STD\PYGZus{}LOGIC\PYGZus{}VECTOR}\PYG{p}{(}\PYG{n}{N} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{pdi\PYGZus{}valid} \PYG{o}{:} \PYG{k}{in}  \PYG{k+kt}{STD\PYGZus{}LOGIC}\PYG{p}{;}
         \PYG{n}{pdi\PYGZus{}ready} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{STD\PYGZus{}LOGIC}\PYG{p}{;}
         \PYG{n}{sdi\PYGZus{}data}  \PYG{o}{:} \PYG{k}{in}  \PYG{k+kt}{STD\PYGZus{}LOGIC\PYGZus{}VECTOR}\PYG{p}{(}\PYG{n}{N} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{sdi\PYGZus{}valid} \PYG{o}{:} \PYG{k}{in}  \PYG{k+kt}{STD\PYGZus{}LOGIC}\PYG{p}{;}
         \PYG{n}{sdi\PYGZus{}ready} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{STD\PYGZus{}LOGIC}\PYG{p}{;}
         \PYG{n}{do\PYGZus{}data}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{STD\PYGZus{}LOGIC\PYGZus{}VECTOR}\PYG{p}{(}\PYG{n}{N} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{do\PYGZus{}valid}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{STD\PYGZus{}LOGIC}\PYG{p}{;}
         \PYG{n}{do\PYGZus{}ready}  \PYG{o}{:} \PYG{k}{in}  \PYG{k+kt}{STD\PYGZus{}LOGIC}
        \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{dummy}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{behav} \PYG{k}{of} \PYG{n+nc}{dummy} \PYG{k}{is}
    \PYG{k}{type} \PYG{n}{state} \PYG{k}{is} \PYG{p}{(}\PYG{n}{IDLE}\PYG{p}{,} \PYG{n}{RUN}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{signal} \PYG{n}{current\PYGZus{}state}             \PYG{o}{:} \PYG{n}{state}\PYG{p}{;}
    \PYG{k}{signal} \PYG{n}{next\PYGZus{}state}                \PYG{o}{:} \PYG{n}{state}\PYG{p}{;}
    \PYG{k}{signal} \PYG{n}{cnt\PYGZus{}clr}\PYG{p}{,} \PYG{n}{cnt\PYGZus{}en}\PYG{p}{,} \PYG{n}{cnt\PYGZus{}done} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{k}{signal} \PYG{n}{cnt}\PYG{p}{,} \PYG{n}{next\PYGZus{}cnt}             \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{15} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{begin}

    \PYG{n}{ctrl} \PYG{o}{:} \PYG{k}{process}\PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}
    \PYG{k}{begin}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{rising\PYGZus{}edge}\PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{rst} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
                \PYG{n}{current\PYGZus{}state} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{IDLE}\PYG{p}{;}
            \PYG{k}{else}
                \PYG{n}{current\PYGZus{}state} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{next\PYGZus{}state}\PYG{p}{;}
            \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}

        \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}

    \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

    \PYG{n}{comb} \PYG{o}{:} \PYG{k}{process}\PYG{p}{(}\PYG{n}{current\PYGZus{}state}\PYG{p}{,} \PYG{n}{pdi\PYGZus{}valid}\PYG{p}{,} \PYG{n}{sdi\PYGZus{}valid}\PYG{p}{,} \PYG{n}{do\PYGZus{}ready}\PYG{p}{,} \PYG{n}{cnt\PYGZus{}done}\PYG{p}{)}
    \PYG{k}{begin}
        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} defaults}
        \PYG{n}{pdi\PYGZus{}ready} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
        \PYG{n}{sdi\PYGZus{}ready} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
        \PYG{n}{do\PYGZus{}valid}  \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
        \PYG{n}{cnt\PYGZus{}clr}   \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
        \PYG{n}{cnt\PYGZus{}en}    \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}

        \PYG{k}{case} \PYG{n}{current\PYGZus{}state} \PYG{k}{is}
            \PYG{k}{when} \PYG{n}{IDLE} \PYG{o}{=}\PYG{o}{\PYGZgt{}}
                \PYG{n}{cnt\PYGZus{}clr} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
                \PYG{k}{if} \PYG{n}{pdi\PYGZus{}valid} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{and} \PYG{n}{sdi\PYGZus{}valid} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{and} \PYG{n}{do\PYGZus{}ready} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{then}
                    \PYG{n}{next\PYGZus{}state} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{RUN}\PYG{p}{;}
                \PYG{k}{else}
                    \PYG{n}{next\PYGZus{}state} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{IDLE}\PYG{p}{;}
                \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}

            \PYG{k}{when} \PYG{n}{RUN} \PYG{o}{=}\PYG{o}{\PYGZgt{}}
                \PYG{k}{if} \PYG{n}{cnt\PYGZus{}done} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{then}
                    \PYG{n}{next\PYGZus{}state} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{IDLE}\PYG{p}{;}
                \PYG{k}{else}
                    \PYG{k}{if} \PYG{n}{pdi\PYGZus{}valid} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{and} \PYG{n}{sdi\PYGZus{}valid} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{and} \PYG{n}{do\PYGZus{}ready} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{then}
                        \PYG{n}{pdi\PYGZus{}ready} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
                        \PYG{n}{sdi\PYGZus{}ready} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
                        \PYG{n}{do\PYGZus{}valid}  \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
                        \PYG{n}{cnt\PYGZus{}en}    \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
                    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
                    \PYG{n}{next\PYGZus{}state} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{RUN}\PYG{p}{;}
                \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}

            \PYG{k}{when} \PYG{k}{others} \PYG{o}{=}\PYG{o}{\PYGZgt{}}
                \PYG{n}{next\PYGZus{}state} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{IDLE}\PYG{p}{;}

        \PYG{k}{end} \PYG{k}{case}\PYG{p}{;}

    \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}
    \PYG{c+c1}{\PYGZhy{}\PYGZhy{}do\PYGZus{}data \PYGZlt{}= pdi\PYGZus{}data xor sdi\PYGZus{}data;}
    \PYG{n}{do\PYGZus{}data} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{pdi\PYGZus{}data}\PYG{p}{;}

    \PYG{n}{count} \PYG{o}{:} \PYG{k}{process}\PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}
    \PYG{k}{begin}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{rising\PYGZus{}edge}\PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
            \PYG{n}{cnt} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{next\PYGZus{}cnt}\PYG{p}{;}
        \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}
    \PYG{n}{next\PYGZus{}cnt} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{p}{(}\PYG{k}{others} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{)} \PYG{k}{when} \PYG{n}{cnt\PYGZus{}clr} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}
                \PYG{k}{else} \PYG{n}{cnt} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{k}{when} \PYG{n}{cnt\PYGZus{}en} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}
                \PYG{k}{else} \PYG{n}{cnt}\PYG{p}{;}

    \PYG{n}{cnt\PYGZus{}done} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{n}{NUMWORDS}\PYG{p}{)} \PYG{k}{else} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}

\PYG{k}{end} \PYG{n+nc}{behav}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Generating the dummy DUT bitstream}
\label{\detokenize{dutdev:generating-the-dummy-dut-bitstream}}
This procedure describes how to genrate the bitstream for the dummy DUT. You don’t need to perform
this procedure to run the dummy example since the bitstream is already generated.
However, this procedure aims to show how to instantiate a function core in FOBOS DUT wrapper.

1. Create a project in Vivado (or ISE) and add all vhdl files from fobos/capture/dut/fpga\_dut (except half\_duplex\_du.vhd)
and fobos/capture/dut/example\_cores/dummy1.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Note that in FOBOS\_DUT.vhd, the dummy dut is instantaited as follows:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{victim}\PYG{o}{:} \PYG{k}{entity} \PYG{n+nc}{work}\PYG{p}{.}\PYG{n}{dummy}\PYG{p}{(}\PYG{n}{behav}\PYG{p}{)}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} Choices for W and SW are independently any multiple of 4, defined in generics above}

    \PYG{k}{generic} \PYG{k}{map}  \PYG{p}{(}
        \PYG{n}{N}          \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{8}\PYG{p}{,}
        \PYG{n}{NUMWORDS}        \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{7}
    \PYG{p}{)}

\PYG{k}{port} \PYG{k}{map}\PYG{p}{(}
    \PYG{n}{clk} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{clk}\PYG{p}{,}
    \PYG{n}{rst} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{,}  \PYG{c+c1}{\PYGZhy{}\PYGZhy{}! The FOBOS\PYGZus{}DUT start signal meets requirements}
                   \PYG{c+c1}{\PYGZhy{}\PYGZhy{}!for synchronous resets used in}
                   \PYG{c+c1}{\PYGZhy{}\PYGZhy{}! CAESAR HW Development Package AEAD}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} data signals}

    \PYG{n}{pdi\PYGZus{}data}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{pdi\PYGZus{}data}\PYG{p}{,}
    \PYG{n}{pdi\PYGZus{}valid} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{pdi\PYGZus{}valid}\PYG{p}{,}
    \PYG{n}{pdi\PYGZus{}ready} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{pdi\PYGZus{}ready}\PYG{p}{,}

\PYG{n}{sdi\PYGZus{}data} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sdi\PYGZus{}data}\PYG{p}{,}
    \PYG{n}{sdi\PYGZus{}valid} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sdi\PYGZus{}valid}\PYG{p}{,}
    \PYG{n}{sdi\PYGZus{}ready} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sdi\PYGZus{}ready}\PYG{p}{,}

    \PYG{n}{do\PYGZus{}data} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{result\PYGZus{}data}\PYG{p}{,}
    \PYG{n}{do\PYGZus{}ready} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{result\PYGZus{}ready}\PYG{p}{,}
    \PYG{n}{do\PYGZus{}valid} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{result\PYGZus{}valid}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}! if rdi\PYGZus{}interface for side\PYGZhy{}channel protected versions is required,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}! uncomment the rdi interface}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}  ,rdi\PYGZus{}data =\PYGZgt{} rdi\PYGZus{}data,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}  rdi\PYGZus{}ready =\PYGZgt{} rdi\PYGZus{}ready,}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{}  rdi\PYGZus{}valid =\PYGZgt{} rdi\PYGZus{}valid}

\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
Note that the W and SW (PDI and SDI width) generics in FOBOS\_DUT.vhd are set to 8.

\item {} 
Add the constain file CW305.xdc for NewAE CW305 (or Nexys3.ucf for Nexys3 DUT) from fobos/capture/dut/fpga\_dut.

\item {} 
Generate the bitstream.

\item {} 
Find your bitstream file FOBOS\_DUT.bit in the Vivado/ISE project folders.

\end{enumerate}


\section{Running the dummu DUT example (on Nexys3 DUT)}
\label{\detokenize{dutdev:running-the-dummu-dut-example-on-nexys3-dut}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Make sure your hardware is setup properly and the DUT is connected to the control board.

\item {} 
Run the dummyDUTCapture.py script as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd path\PYGZhy{}to\PYGZhy{}fobos/software
\PYGZdl{} python dummyDUTCapture.py
\end{sphinxVerbatim}

\end{enumerate}

This script is preconfigured to use the fobos/workspace/DummyProject as a project folder.
The folder includes a pre-generated bitstream file that FOBOS will use to program the Nexys3 DUT.
This requires digilent Adept tool ‘djtgcfg’ to be installed and callable from the Linux shell.
The project folder also includes a pre-generated test vector file ‘dinFile.txt’.


\chapter{Data Acquisition - Processing Data}
\label{\detokenize{capture_data:data-acquisition-processing-data}}\label{\detokenize{capture_data::doc}}
After test vectors have been generated, user can run data acquisition (capture). The PC will send one test vector at a time to the control board, which sends it to DUT. The control board will trigger the oscilloscope to capture the trace. The process will be repeated until all traces are collected.


\section{FOBOS control-DUT protocol}
\label{\detokenize{capture_data:fobos-control-dut-protocol}}
The control board receives test vectors from the PC one at a time. Then, it sends the vector to the DUT
which uses the header information in the vector to put the data (plaintext, key etc.) into the correct FIFOs.
The DUT wrapper then allows the victim algorithm to run by setting the victim reset to zero. The victim then drains the FIFOs
(sdi and pdi FIFOs) and stores the output in the DO FIFO. Once the DO FIFO accumulates the expected amount of data,
the DUT wrapper sends data to the controller which sends it to the PC.

The following diagram shows the components of FOBOS.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{fobos2-block}.png}
\caption{FOBOS2 Block Diagram}\label{\detokenize{capture_data:id1}}\end{figure}


\section{A Basic Example}
\label{\detokenize{capture_data:a-basic-example}}
Below, we show an example of using the controller internal test feature. When enabled, the controller process the data and echo back the
PDI without sending the data to the DUT.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{k+kn}{import} \PYG{n+nn}{fobos}
 \PYG{c+c1}{\PYGZsh{} Constants\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
 \PYG{n}{SERIAL\PYGZus{}PORT} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/dev/ttyUSB1}\PYG{l+s+s1}{\PYGZsq{}}
 \PYG{n}{TRACE\PYGZus{}NUM} \PYG{o}{=} \PYG{l+m+mi}{5}
 \PYG{n}{OUT\PYGZus{}LEN} \PYG{o}{=} \PYG{l+m+mi}{7}
 \PYG{c+c1}{\PYGZsh{} Instantiate FOBOS objects\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
 \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sending configuration...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
 \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{fobos}\PYG{o}{.}\PYG{n}{Basys3Ctrl}\PYG{p}{(}\PYG{n}{SERIAL\PYGZus{}PORT}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{enableTestMode}\PYG{p}{(}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setOutLen}\PYG{p}{(}\PYG{n}{OUT\PYGZus{}LEN}\PYG{p}{)}
 \PYG{c+c1}{\PYGZsh{} Run DUT operations}
 \PYG{n}{testVectors} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c0000761996dc996d4ac00c100070f7821507a22a00081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c00007fd8771fe717de400c100073e1fe5b4aa357c0081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c0000782051f5484702200c10007980d05d4ea25bc0081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c0000767881b702afe5200c10007b08a5e036de72b0081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c0000726a1d601ccdf7a00c1000773539e52672d5d0081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

 \PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sending data..}\PYG{l+s+s1}{\PYGZsq{}}
 \PYG{n}{traceNum} \PYG{o}{=} \PYG{l+m+mi}{0}
 \PYG{k}{while} \PYG{n}{traceNum} \PYG{o}{\PYGZlt{}} \PYG{n}{TRACE\PYGZus{}NUM}\PYG{p}{:}
     \PYG{n}{data} \PYG{o}{=} \PYG{n}{testVectors}\PYG{p}{[}\PYG{n}{traceNum}\PYG{p}{]}
     \PYG{n}{status}\PYG{p}{,} \PYG{n}{result} \PYG{o}{=} \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{processData}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{OUT\PYGZus{}LEN}\PYG{p}{)}
     \PYG{k}{if} \PYG{n}{status} \PYG{o}{!=} \PYG{n}{fobos}\PYG{o}{.}\PYG{n}{OK}\PYG{p}{:}
         \PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TIMEOUT}\PYG{l+s+s2}{\PYGZdq{}}
     \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
     \PYG{n}{traceNum} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

If you run the code above, the control board will echo the PDI as shown below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd path\PYGZhy{}to\PYGZhy{}fobos/software
\PYGZdl{} python dummyCaptureBasic.py
Sending configuration...
f0030006000900000001
Status= 00000000
f0030006000000000007
Status= 00000000
Sending data..
f001001e00c0000761996dc996d4ac00c100070f7821507a22a00081000700800001
OK.    Status= 00000000
61 99 6d c9 96 d4 ac
f001001e00c00007fd8771fe717de400c100073e1fe5b4aa357c0081000700800001
OK.    Status= 00000000
fd 87 71 fe 71 7d e4
f001001e00c0000782051f5484702200c10007980d05d4ea25bc0081000700800001
OK.    Status= 00000000
82 05 1f 54 84 70 22
f001001e00c0000767881b702afe5200c10007b08a5e036de72b0081000700800001
OK.    Status= 00000000
67 88 1b 70 2a fe 52
f001001e00c0000726a1d601ccdf7a00c1000773539e52672d5d0081000700800001
OK.    Status= 00000000
26 a1 d6 01 cc df 7a
\end{sphinxVerbatim}


\section{An Extended Example}
\label{\detokenize{capture_data:an-extended-example}}
The following example shows how to test the controller using the internal test feature. However, this time
we show more features like setting the DUT clock and timeout etc.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{k+kn}{import} \PYG{n+nn}{os}
 \PYG{k+kn}{import} \PYG{n+nn}{shutil}
 \PYG{k+kn}{import} \PYG{n+nn}{fobos}
 \PYG{c+c1}{\PYGZsh{} Constants\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
 \PYG{n}{WORKSPACE} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../workspace/fobosworkspace}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{PROJECT\PYGZus{}NAME} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dummyProject}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{DIN\PYGZus{}FILE\PYGZus{}NAME} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dinFile.txt}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{CIPHER\PYGZus{}FILE} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ciphertext.txt}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{TRACE\PYGZus{}FILE} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{powerTraces.npy}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{DUT\PYGZus{}BIT\PYGZus{}FILE} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FOBOS\PYGZus{}DUT.bit}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{SERIAL\PYGZus{}PORT} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/dev/ttyUSB1}\PYG{l+s+s1}{\PYGZsq{}}
 \PYG{n}{TRACE\PYGZus{}NUM} \PYG{o}{=} \PYG{l+m+mi}{5}
 \PYG{n}{DUT\PYGZus{}CLk} \PYG{o}{=} \PYG{l+m+mi}{1}
 \PYG{n}{OUT\PYGZus{}LEN} \PYG{o}{=} \PYG{l+m+mi}{7}
 \PYG{n}{TIMEOUT} \PYG{o}{=} \PYG{l+m+mi}{5}
 \PYG{n}{TRIG\PYGZus{}WAIT} \PYG{o}{=} \PYG{l+m+mi}{1}
 \PYG{n}{TRIG\PYGZus{}LENGTH} \PYG{o}{=} \PYG{l+m+mi}{1}
 \PYG{n}{TRIG\PYGZus{}MODE\PYGZus{}NORM} \PYG{o}{=} \PYG{l+m+mi}{0}
 \PYG{n}{TRIG\PYGZus{}MODE\PYGZus{}FULL} \PYG{o}{=} \PYG{l+m+mi}{1}
 \PYG{n}{TIME\PYGZus{}TO\PYGZus{}RST} \PYG{o}{=} \PYG{l+m+mi}{0}
 \PYG{c+c1}{\PYGZsh{} Instantiate FOBOS objects\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
 \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{fobos}\PYG{o}{.}\PYG{n}{Basys3Ctrl}\PYG{p}{(}\PYG{n}{SERIAL\PYGZus{}PORT}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setDUTClk}\PYG{p}{(}\PYG{n}{DUT\PYGZus{}CLk}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{enableTestMode}\PYG{p}{(}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setTimeToReset}\PYG{p}{(}\PYG{n}{TIME\PYGZus{}TO\PYGZus{}RST}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setOutLen}\PYG{p}{(}\PYG{n}{OUT\PYGZus{}LEN}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setTimeout}\PYG{p}{(}\PYG{n}{TIMEOUT}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setTriggerWait}\PYG{p}{(}\PYG{n}{TRIG\PYGZus{}WAIT}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setTriggerLen}\PYG{p}{(}\PYG{n}{TRIG\PYGZus{}LENGTH}\PYG{p}{)}
 \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setTriggerMode}\PYG{p}{(}\PYG{n}{TRIG\PYGZus{}MODE\PYGZus{}FULL}\PYG{p}{)}

 \PYG{c+c1}{\PYGZsh{} Configure project directories\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
 \PYG{n}{pm} \PYG{o}{=} \PYG{n}{fobos}\PYG{o}{.}\PYG{n}{ProjectManager}\PYG{p}{(}\PYG{p}{)}
 \PYG{n}{pm}\PYG{o}{.}\PYG{n}{setWorkSpaceDir}\PYG{p}{(}\PYG{n}{WORKSPACE}\PYG{p}{)}
 \PYG{n}{pm}\PYG{o}{.}\PYG{n}{setProjName}\PYG{p}{(}\PYG{n}{PROJECT\PYGZus{}NAME}\PYG{p}{)}
 \PYG{n}{projDir} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{getProjDir}\PYG{p}{(}\PYG{p}{)}

 \PYG{n}{tvFileName} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{projDir}\PYG{p}{,} \PYG{n}{DIN\PYGZus{}FILE\PYGZus{}NAME}\PYG{p}{)}
 \PYG{n}{tvFile} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{tvFileName}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
 \PYG{n}{captureDir} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{getCaptureDir}\PYG{p}{(}\PYG{p}{)}
 \PYG{n}{cipherFileName} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{captureDir}\PYG{p}{,} \PYG{n}{CIPHER\PYGZus{}FILE}\PYG{p}{)}
 \PYG{n}{cipherFile} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{cipherFileName}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
 \PYG{n}{shutil}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{tvFileName}\PYG{p}{,} \PYG{n}{captureDir}\PYG{p}{)}
 \PYG{c+c1}{\PYGZsh{} Get traces\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
 \PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sending data..}\PYG{l+s+s1}{\PYGZsq{}}
 \PYG{n}{traceNum} \PYG{o}{=} \PYG{l+m+mi}{0}
 \PYG{k}{while} \PYG{n}{traceNum} \PYG{o}{\PYGZlt{}} \PYG{n}{TRACE\PYGZus{}NUM}\PYG{p}{:}
     \PYG{n}{data} \PYG{o}{=} \PYG{n}{tvFile}\PYG{o}{.}\PYG{n}{readline}\PYG{p}{(}\PYG{p}{)}
     \PYG{n}{status}\PYG{p}{,} \PYG{n}{result} \PYG{o}{=} \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{processData}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{OUT\PYGZus{}LEN}\PYG{p}{)}
     \PYG{k}{if} \PYG{n}{status} \PYG{o}{!=} \PYG{n}{fobos}\PYG{p}{:}
         \PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TIMEOUT}\PYG{l+s+s2}{\PYGZdq{}}
     \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
     \PYG{n}{cipherFile}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{result} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
     \PYG{n}{traceNum} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

 \PYG{n}{tvFile}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
 \PYG{n}{cipherFile}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

This script connects to the Basys3 controller, configure the controller and then prepares the input and output files.
Once this setup is done, the script reads the input test vector file and sends one line at a time to the controller to process it.
The controller sends the data to the DUT (in this example we use the internal dummy DUT).

Here is a line by line description of the code.
lines 1-3 imports packages the we will need in the code. The fobos package is the package we need to have access to the classes we need to communicate
with the controller and other useful tools.

Lines 22-30 configures the controller. we set the following parameters
\begin{itemize}
\item {} 
The DUT clock frequency is set to 1 MHz. This is the clock generated by the control board and used to clock the DUT.

\item {} 
Test mode is enabled. In this mode, the controller uses its internal dummy DUT to process data. This DUT simply echoes PDI.

\item {} 
Time-to-reset is set to 0. This disables this feature. If set to a number greater than zero, the DUT will be reset after
that number of clock cycles.

\item {} 
The controller timeout is set to 5 seconds. The control board will wait for 5 seconds for the DUT to respond before giving up.

\item {} 
The trigger mode is set to Normal mode, trigger wait cycles to 1 and trigger length to 1. For more information about he trigger module,
please refer to {[}ref trigger{]}

\end{itemize}

Lines 33-43 configures the workspace. The ProjectManager class is used to setup a simple directory structure to store input and output files.
Each run of this scripts creates a new directory to store the output files.
This script expects all data to be in WORKSPACE/PROJECT\_NAME directory (created by the user). The user should also put the test vector file
‘dinFile.txt’ that directory. All results will be saved in the WORKSPACE/PROJECT\_NAME/Capture. A new directory will be created for each new run.
Also, different files are specified relative to the project directory.

Lines 46-56 reads the test vector file one line at a time and sends it to the control board which processes it and sends back the result.


\chapter{Data Acquisition - Collecting Traces}
\label{\detokenize{capture_scope:data-acquisition-collecting-traces}}\label{\detokenize{capture_scope::doc}}
This section explains how to use PicoScope to collect traces. This is best explained by example.


\section{PicoScope Setup}
\label{\detokenize{capture_scope:picoscope-setup}}
This example code uses the Picoscope 5000 series (5244D) oscilloscope. To setup the oscilloscope please
refer to the manufacturer website.
We expect that modifying the code to work with other series to be easy since the manufacturer provides an SDK.


\section{Power Measurement (Nexy3 DUT)}
\label{\detokenize{capture_scope:power-measurement-nexy3-dut}}
The oscilloscope must be able to measure a voltage propotional to the power consumed by the device.
You can use a current probe (e.g Tektronix CT-1). We modified the DUT board so that we
have a jumper on the power line (core FPGA voltage).
We then used a bench power supply to power the FPGA (1.2V). Note that the power wire should go through the current probe.
The power probe senses the current variations in the power wire and coverts that to volatge for the oscilloscope.

An alternative method is to insert a shunt resistor in the power line and then measure the volatge drop
across the resistor.


\section{Trace Collection Example}
\label{\detokenize{capture_scope:trace-collection-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{fobos}
\PYG{c+c1}{\PYGZsh{} Constants\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{SERIAL\PYGZus{}PORT} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/dev/ttyUSB1}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{TRACE\PYGZus{}NUM} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{OUT\PYGZus{}LEN} \PYG{o}{=} \PYG{l+m+mi}{7}
\PYG{c+c1}{\PYGZsh{} Instantiate FOBOS objects\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sending configuration...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{fobos}\PYG{o}{.}\PYG{n}{Basys3Ctrl}\PYG{p}{(}\PYG{n}{SERIAL\PYGZus{}PORT}\PYG{p}{)}
\PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{enableTestMode}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{setOutLen}\PYG{p}{(}\PYG{n}{OUT\PYGZus{}LEN}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} open file to save traces.}
\PYG{n}{traceFile} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{powerTraces.npy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} configure oscilloscope}
\PYG{n}{scope} \PYG{o}{=} \PYG{n}{fobos}\PYG{o}{.}\PYG{n}{picoscope}\PYG{o}{.}\PYG{n}{Picoscope}\PYG{p}{(}\PYG{n}{sampleResolution} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} number of bits for each sample.}
                    \PYG{n}{postTriggerSamples} \PYG{o}{=} \PYG{l+m+mi}{1000} \PYG{c+c1}{\PYGZsh{} samples in one trace.}
                    \PYG{p}{)}
\PYG{n}{scope}\PYG{o}{.}\PYG{n}{setChannel}\PYG{p}{(}\PYG{n}{channelName} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CHANNEL\PYGZus{}A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rangemv} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{100mV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{scope}\PYG{o}{.}\PYG{n}{setSamplingInterval}\PYG{p}{(}\PYG{n}{samplingIntervalns} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} T=2 ns, Sampling rate= 500MHz}
\PYG{n}{scope}\PYG{o}{.}\PYG{n}{setTrigger}\PYG{p}{(}\PYG{n}{channelName} \PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{EXTERNAL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{direction} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RISING\PYGZus{}EDGE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{n}{thresholdmv} \PYG{o}{=} \PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{scope}\PYG{o}{.}\PYG{n}{setDataBuffers}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Run DUT operations}
\PYG{n}{testVectors} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c0000761996dc996d4ac00c100070f7821507a22a00081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c00007fd8771fe717de400c100073e1fe5b4aa357c0081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c0000782051f5484702200c10007980d05d4ea25bc0081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c0000767881b702afe5200c10007b08a5e036de72b0081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00c0000726a1d601ccdf7a00c1000773539e52672d5d0081000700800001}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sending data..}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{traceNum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{while} \PYG{n}{traceNum} \PYG{o}{\PYGZlt{}} \PYG{n}{TRACE\PYGZus{}NUM}\PYG{p}{:}
    \PYG{n}{scope}\PYG{o}{.}\PYG{n}{arm}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} arm scope. Now, it expects a trigger at any time.}
    \PYG{n}{data} \PYG{o}{=} \PYG{n}{testVectors}\PYG{p}{[}\PYG{n}{traceNum}\PYG{p}{]}
    \PYG{n}{status}\PYG{p}{,} \PYG{n}{result} \PYG{o}{=} \PYG{n}{ctrl}\PYG{o}{.}\PYG{n}{processData}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{OUT\PYGZus{}LEN}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{status} \PYG{o}{!=} \PYG{n}{fobos}\PYG{o}{.}\PYG{n}{OK}\PYG{p}{:}
        \PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TIMEOUT}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
    \PYG{n}{trace} \PYG{o}{=} \PYG{n}{scope}\PYG{o}{.}\PYG{n}{readTrace}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} get trace from oscilloscope buffers.}
    \PYG{n}{np}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{traceFile}\PYG{p}{,} \PYG{n}{trace}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} save the trace in the trace file.}
    \PYG{n}{traceNum} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

This is very similar to the capture data example but with few more lines added to capture traces
from the oscilloscope.

Lines 15-22 configure the oscilloscope settings. We first intantiate a Picoscope object (line 15).
Lines  15 sets sampleResolution to 8 bit and number of samples to be collected to 1000 samples per trace.
Line 18 enables channel A and sets its range to 100 mV.
Line 19 sets the sampling interval (T) to 2 nano seconds. This implies that ampling rate is 1/T = 500 M Sample/s.
Line 20 configers the EXTERNAL (Ext) channel to be used for trigger on risinge edge with a threshold of 200 mV.
Trigger channel must be connected to the control board trigger output.
Line 22 allocates memory buffers to store oscilloscope data.

In the main loop, we use the arm() (line 34) function to tell the oscilloscope to be ready to get the trigger and store the
data. Once the crypto operation is over, we can collect the trace from the memory as a numpy array using the
readTrace() method (line 40). The trace is saved into a file in line 41.
For more information about the PicoScope class see {\hyperref[\detokenize{reference_doc:Picoscope}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Picoscope}}}}}.


\chapter{Control Board Feature}
\label{\detokenize{controller_features:control-board-feature}}\label{\detokenize{controller_features::doc}}

\section{Trigger Settings}
\label{\detokenize{controller_features:trigger-settings}}
The controller can send a trigger to the Oscilloscope once the DUT starts processing the data (ie. di\_ready = 0). Or it can be configured to trigger any number of clock cycles after this event occurs.
\begin{itemize}
\item {} 
TRIGGER\_WAIT\_CYCLES : The number of clock cycles after which the trigger is asserted (after di\_ready goes to zero).

\item {} 
TRIGGER\_LENGTH\_CYCLES : The time the trigger signal is asserted.

\item {} \begin{description}
\item[{TRIGGER\_TYPE}] \leavevmode{[}possible values: TRG\_NORM \textbar{} TRG\_FULL \textbar{} TRG\_NORM\_CLK \textbar{} TRG\_FULL\_CLK{]}\begin{itemize}
\item {} 
TRG\_NORM : normal trigger mode. in this mode the TRIGGER\_WAIT\_CYCLES and TRIGGER\_LENGTH\_CYCLES are applied.

\item {} 
TRG\_FULL : Full trigger mode. While DUT is running (between di\_ready = 0 and do\_valid = 1) the trigger is asserted.

\item {} 
TRG\_NORM\_CLK : same as TRG\_NORM but the trigger signal is anded with the clock.

\item {} 
TRG\_FULL\_CLK : same as TRG\_FULL but the trigger signal is anded with the clock.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{CUT\_MODE}] \leavevmode{[}Controls how the trace retrieved from the scope will be processed. Possible values: FULL \textbar{} TRIG\_HIGH{]}\begin{itemize}
\item {} 
FULL : The trace is cut starting at the rising edge of the trigger to the end of the screen.

\item {} 
TRIG\_HIGH : the trace is cut from the rising edge to the falling edge of the trigger ie. the trace where the trigger is high will be saved.

\end{itemize}

\end{description}

\end{itemize}


\section{Setting DUT Clock}
\label{\detokenize{controller_features:setting-dut-clock}}
The control board can provide a clock for the DUT ranging from 400 KHz to 100 MHz. The default value is 5 MHz.
To set it, use the following method:
\begin{quote}

ctrl.setDUTClk(clkValue).
\end{quote}


\section{DUT Reset Feature}
\label{\detokenize{controller_features:dut-reset-feature}}
In some cases, the control board may need to reset the DUT because the interesting part of the victim algorithm has already executed. This is specifically valuable for ciphers that take a long time to complete. In this case, the cipher runs for a configurable number of clock cycles and then is reset without waiting for it to complete. This helps reduce acquisition time.
The number of cycles is counted after di\_ready goes to 0.
Note: When you use this feature, no output is returned from the DUT.
To set it use the following command and set TIME\_TO\_RESET to any number other than zero. This number is set to zero by default which disables this feature.
\begin{quote}

ctrl.setTimeToReset(TIME\_TO\_RST)
\end{quote}


\section{Timeout Setting}
\label{\detokenize{controller_features:timeout-setting}}
In some cases, due to communication error or DUT non-responsiveness the control board sends a
timeout error message to the control PC when a configurable time has elapsed. The default value is 5
seconds which is enough for almost all cases. Once timeout is reached, the control board resets the DUT, clears any pending DUT data transfers and return the a timeout status to the capture software.
To set the timeout value, use the method:
\begin{quote}

ctrl.setTimeout(TIMEOUT)
\end{quote}


\section{Port mapping}
\label{\detokenize{controller_features:port-mapping}}
Below, we show how the pins on the Basys3 PMOD ports are assinged.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}JA}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}  din3    \textbar{}  do\PYGZus{}ready\textbar{}  rst     \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  G2      \textbar{}  J2      \textbar{}  L2      \textbar{}  J1      \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  din0    \textbar{}  din2    \textbar{}  din1    \textbar{}  do\PYGZus{}valid\textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  G3      \textbar{}  H2      \textbar{}  K2      \textbar{}  H1      \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{c+c1}{\PYGZsh{}JXADC}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  dout1   \textbar{}  dout3   \textbar{}  di\PYGZus{}ready\textbar{}  dut\PYGZus{}clk \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  N2      \textbar{}  M2      \textbar{}  L3      \textbar{}  J3      \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}  dout0   \textbar{}  dout2   \textbar{}  di\PYGZus{}valid\textbar{}          \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}  N1      \textbar{}  M1      \textbar{}  M3      \textbar{}  K3      \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}

\PYG{c+c1}{\PYGZsh{}JC}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}          \textbar{}          \textbar{} trigger\PYGZus{}out\textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}          \textbar{}          \textbar{}            \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}          \textbar{}          \textbar{}            \textbar{}}
\PYG{c+c1}{\PYGZsh{}\textbar{}          \textbar{}          \textbar{}          \textbar{}            \textbar{}}
\PYG{c+c1}{\PYGZsh{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\end{sphinxVerbatim}


\chapter{Running Correlation Power Analysis}
\label{\detokenize{cpa:running-correlation-power-analysis}}\label{\detokenize{cpa::doc}}
One of the most used variants of Deferential Power Analysis (DPA) is Correlation Power Analysis (CPA). In this document, we show the theory
behind CPA before showing concrete examples.
This discussion follows the notation and concepts discussed in
the book “Power Analysis Attacks - Revealing the secrets of Smart Cards” by Mangard, Oswald and Popp.


\section{How CPA Works?}
\label{\detokenize{cpa:how-cpa-works}}
Correlation Power Analysis uses an intermediate value that is a function of part of the key and known data.
The power consumption of the devices when the intermediate value is processed is estimated for each key guess.
A statistical method is then used to find out which key was most likely used by correlating the hypothetical power and the real power consumption.
below we discuss this process in detail.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{cpa_flow}.png}
\caption{CPA Flow}\label{\detokenize{cpa:id1}}\end{figure}


\subsection{Step 1: Choose the intermediate value}
\label{\detokenize{cpa:step-1-choose-the-intermediate-value}}
We choose an intermediate variable that is processed in the algorithm. The intermediate value is calculated as \sphinxstyleemphasis{f(d, k)}
Where \sphinxstyleemphasis{d} is a known non-constant value that can be derived from known data (e.g. plain text) and \sphinxstyleemphasis{k} is small part of the key.


\subsection{Step 2: Power measurement}
\label{\detokenize{cpa:step-2-power-measurement}}
Measure the power consumption of the  crypto device while it encrypts/decrypts D data blocks.
We need to know the value \sphinxstyleemphasis{d} the corresponds to each data block. These values can be written as a vector \sphinxstylestrong{d} = {[}d$_{\text{1}}$, d$_{\text{2}}$, …, d$_{\text{D}}${]}.
The power consumption signal for a single encryption/decryption operation is called a trace.
A trace is vector that records instantaneous power consumption for the time of interest (the time when the intermediate value is being processed).
The trace generated while encrypting/decrypting data block \sphinxstyleemphasis{i} consists of \sphinxstyleemphasis{T} samples and can be viewed as a vector \sphinxstylestrong{t}$_{\text{i}}$ = {[}t$_{\text{i,1}}$, t$_{\text{i,2}}$,… , t$_{\text{i,T}}${]}.
The traces are stacked in a matrix \sphinxstylestrong{T} with dimensions \sphinxstyleemphasis{D x T} where each row i is a trace generated while encrypting/decrypting block \sphinxstyleemphasis{i}.


\subsection{Step 3: Calculate hypothetical intermediate}
\label{\detokenize{cpa:step-3-calculate-hypothetical-intermediate}}
Next, we need to guess the key part that goes into the calculation of the intermediate value. We list all possible sub keys as a vector \sphinxstylestrong{k} = {[}k$_{\text{1}}$, k $_{\text{2}}$ ,…., k$_{\text{K}}${]}.
Then, we calculate the intermediate value \sphinxstyleemphasis{f(d, k)} for all values in the vectors \sphinxstylestrong{d} and \sphinxstylestrong{k}. The result is stored in a \sphinxstyleemphasis{D x K} matrix \sphinxstylestrong{V}.
Where

\sphinxstylestrong{V}$_{\text{i,j}}$ = f(d$_{\text{i}}$, k$_{\text{j}}$)

and \sphinxstyleemphasis{i = 1, 2, …D and j = 1, 2 …K}

Note that each column in \sphinxstylestrong{V} is the intermediate value calculated for all data values \sphinxstylestrong{d} for one key guess.


\subsection{Step 4: Calculate Hypothetical Power}
\label{\detokenize{cpa:step-4-calculate-hypothetical-power}}
Now we have calculated the intermediate values matrix \sphinxstylestrong{V}, we estimate the power consumption when each value in \sphinxstylestrong{V} is processed in the device.
Two power models are widely used:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
The Hamming Weight model (HW). this model counts the ones in the value e.g HW(1100 0000) = 2

\item {} 
The Hamming distance model (HD). This model counts the the number of bits that flips when a the value of a variable (e.g. register) changes. That is

\end{enumerate}

HD(x, y) = HW(x \sphinxstyleemphasis{xor} y)

e.g HD(0000 0011, 0000 0101) = HW(0000 0011 \sphinxstyleemphasis{xor} 0000 0101) = HW(0000 0110) = 2

The result is a \sphinxstyleemphasis{D x K} matrix called \sphinxstylestrong{H}. These are the same dimensions as the matrix \sphinxstylestrong{V}.


\subsection{Step 5: Correlate the hypothetical power and the real power traces}
\label{\detokenize{cpa:step-5-correlate-the-hypothetical-power-and-the-real-power-traces}}
We correlate H and T to find the key. The question is: which column in \sphinxstylestrong{V} was most likely processed in the device?
We use a correlation algorithm that takes two vectors as input and returns a real number that measures how ‘similar’ the vectors are.
Each column \sphinxstyleemphasis{i} in \sphinxstylestrong{H} is compared with column \sphinxstyleemphasis{j} in the trace matrix \sphinxstylestrong{T}. The result is stored in the correlation matrix \sphinxstylestrong{R} which is a \sphinxstyleemphasis{K x T} matrix.
Note that column \sphinxstyleemphasis{i} in matrix \sphinxstylestrong{H} is the hypothetical power if \sphinxstylestrong{k}$_{\text{i}}$ is used in the device and column \sphinxstyleemphasis{j} in \sphinxstylestrong{T} is the real power measurement at sample \sphinxstyleemphasis{j} for all data blocks.

The element \sphinxstylestrong{R}$_{\text{i,j}}$ measures how similar the column \sphinxstyleemphasis{i} in \sphinxstylestrong{H} to column \sphinxstyleemphasis{j} in \sphinxstylestrong{T}.
The index of the highest element in the matrix \sphinxstylestrong{R} \sphinxstyleemphasis{ck}, \sphinxstyleemphasis{ct} are the in index of the key and the sample in time of the supposedly correct key since it indicates that the corresponding columns in \sphinxstylestrong{H} and \sphinxstylestrong{T} are similar so it is likely that the guessed key was indeed used in the device.


\chapter{AES CPA Example}
\label{\detokenize{aes_cpa_example2:aes-cpa-example}}\label{\detokenize{aes_cpa_example2::doc}}
This section describes a Correlation Power Analysis (CPA) attack of an implementation of the
Advanced Encryption Standard (AES) using FOBOS. AES is an symmetric-key cipher used ex-
tensively in security sensitive applications world wide. AES applies four different transformations,
SubBytes, ShiftRows, MixColumns, and AddRoundKey, per round and iterates through several
such rounds depending upon the key size. An intermediate key called ”round key” is generated and
used per round which is derived from the original key through a reversible key scheduling function.
We have implemented a basic iterative architecture of AES with 128-bit key length and 128-bit
wide datapath requiring 11 clock cycles for one encryption. Key scheduling is done on-the-fly and
the SubBytes function is realized through look-up-tables. The block diagram for this design is
shown in the figure below:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{aes128}.png}
\caption{AES-128 implementation}\label{\detokenize{aes_cpa_example2:id1}}\end{figure}

We attack our AES design during the first round at the output of the register FF1 (see the figure above). The equation for calculating the Hamming Distance (HD) is shown in the eqation below. We use
Pearson’s Correlation to correlate the instantaneous power consumption with the HD model.
\begin{quote}

H(i,j) = HD(SBOX(CT(i) ), SBOX(kguess(j) xor PT(i+1) ))
\end{quote}

For trace collection, we used the Basys3 control board and connected a NewAE CW305 DUT (Artix7 FPGA).
The DUT clock was set to 1 MHz and the oscilloscope sampling rate was set to 62 M Sample/sec.
We then collected 500K traces.
The formula above was used to generate the hypothetical power matrix.

Below is the script used for the CPA analysis. This script is at fobos/software/cpaExample.py and the example files are
stored in fobos/workspace/aes\_artix7\_picoscope :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{fobos}\PYG{n+nn}{.}\PYG{n+nn}{traceset} \PYG{k}{as} \PYG{n+nn}{traceset}
\PYG{k+kn}{import} \PYG{n+nn}{fobos}\PYG{n+nn}{.}\PYG{n+nn}{cpa} \PYG{k}{as} \PYG{n+nn}{cpa}
\PYG{k+kn}{import} \PYG{n+nn}{fobos}\PYG{n+nn}{.}\PYG{n+nn}{postprocess} \PYG{k}{as} \PYG{n+nn}{postprocess}
\PYG{k+kn}{import} \PYG{n+nn}{fobos}\PYG{n+nn}{.}\PYG{n+nn}{projmgr} \PYG{k}{as} \PYG{n+nn}{projmgr}
\PYG{k+kn}{import} \PYG{n+nn}{fobos}\PYG{n+nn}{.}\PYG{n+nn}{powermodels}\PYG{n+nn}{.}\PYG{n+nn}{AESFirstLast} \PYG{k}{as} \PYG{n+nn}{powermodel}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Configure project directories\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
    \PYG{n}{WORKSPACE} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../workspace/aes\PYGZus{}artix7\PYGZus{}picoscope/capture}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{PROJECT\PYGZus{}NAME} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aes\PYGZus{}artix\PYGZus{}pico\PYGZus{}62MSps}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{pm} \PYG{o}{=} \PYG{n}{projmgr}\PYG{o}{.}\PYG{n}{ProjectManager}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{pm}\PYG{o}{.}\PYG{n}{setWorkSpaceDir}\PYG{p}{(}\PYG{n}{WORKSPACE}\PYG{p}{)}
    \PYG{n}{pm}\PYG{o}{.}\PYG{n}{setProjName}\PYG{p}{(}\PYG{n}{PROJECT\PYGZus{}NAME}\PYG{p}{)}
    \PYG{n}{projDir} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{getProjDir}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{analysisDir} \PYG{o}{=} \PYG{n}{pm}\PYG{o}{.}\PYG{n}{getAnalysisDir}\PYG{p}{(}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
    \PYG{n}{TRACES\PYGZus{}FILE} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{projDir}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{powerTraces.npy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{PLAIN\PYGZus{}FILE} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{projDir}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plaintext.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{CIPHER\PYGZus{}FILE} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{projDir}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ciphertext.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{HYPO\PYGZus{}FILE} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{projDir}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hypotheticalPower.npy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{CROP\PYGZus{}START} \PYG{o}{=} \PYG{l+m+mi}{218}
    \PYG{n}{CROP\PYGZus{}END} \PYG{o}{=} \PYG{l+m+mi}{282}

    \PYG{n}{NUM\PYGZus{}TRACES} \PYG{o}{=} \PYG{l+m+mi}{220000}
    \PYG{n}{MTD\PYGZus{}STRIDE} \PYG{o}{=} \PYG{l+m+mi}{10000}
    \PYG{n}{traceSet} \PYG{o}{=} \PYG{n}{traceset}\PYG{o}{.}\PYG{n}{TraceSet}\PYG{p}{(}\PYG{n}{traceNum}\PYG{o}{=}\PYG{n}{NUM\PYGZus{}TRACES}\PYG{p}{,}
                                \PYG{n}{fileName}\PYG{o}{=}\PYG{n}{TRACES\PYGZus{}FILE}\PYG{p}{,}
                                \PYG{n}{cropStart}\PYG{o}{=}\PYG{n}{CROP\PYGZus{}START}\PYG{p}{,}
                                \PYG{n}{cropEnd}\PYG{o}{=}\PYG{n}{CROP\PYGZus{}END}\PYG{p}{)}

    \PYG{n}{measuredPower} \PYG{o}{=} \PYG{n}{traceSet}\PYG{o}{.}\PYG{n}{traces}
    \PYG{n}{hypotheticalPower} \PYG{o}{=} \PYG{n}{powermodel}\PYG{o}{.}\PYG{n}{getHypotheticalPower}\PYG{p}{(}\PYG{n}{PLAIN\PYGZus{}FILE}\PYG{p}{,}
                                                        \PYG{n}{CIPHER\PYGZus{}FILE}\PYG{p}{,}
                                                        \PYG{n}{NUM\PYGZus{}TRACES}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} hypotheticalPower = np.load(HYPO\PYGZus{}FILE)}
    \PYG{n}{cpaAttacker} \PYG{o}{=} \PYG{n}{cpa}\PYG{o}{.}\PYG{n}{CPA}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{C} \PYG{o}{=} \PYG{n}{cpaAttacker}\PYG{o}{.}\PYG{n}{doCPA}\PYG{p}{(}\PYG{n}{measuredPower}\PYG{o}{=}\PYG{n}{measuredPower}\PYG{p}{,}
                        \PYG{n}{hypotheticalPower}\PYG{o}{=}\PYG{n}{hypotheticalPower}\PYG{p}{,}
                        \PYG{n}{numTraces}\PYG{o}{=}\PYG{n}{NUM\PYGZus{}TRACES}\PYG{p}{,}
                        \PYG{n}{analysisDir}\PYG{o}{=}\PYG{n}{analysisDir}\PYG{p}{,}
                        \PYG{n}{MTDStride}\PYG{o}{=}\PYG{n}{MTD\PYGZus{}STRIDE}
                        \PYG{p}{)}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

In line 7 we import the power model module that will calcualte the hypothetical power matrix.
This module was used in line 35.
After we set the directories and specify input files, we set CROP\_START and CROP\_END which
selects the first round of the encryption in the power trace.
We set the number of traces to be used in the attack using NUM\_TRACES variable and set the step
used in plotting the MTD graph using the variable MTD stride.

Once all setting are complete, we call the doCPA() method in line 40. This method takes the measuredPower matrix,
the hypotheticalPower matrix, the number of traces, the directory used to store results and the MTD stride.

Below, we show the correlation graph and the MTD graph for the first byte of the key.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=350\sphinxpxdimen]{{cpa_correlation}.png}
\caption{CPA Correlation for key byte-0}\label{\detokenize{aes_cpa_example2:id2}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=350\sphinxpxdimen]{{cpa_MTD}.png}
\caption{CPA MTD graph for key byte-0}\label{\detokenize{aes_cpa_example2:id3}}\end{figure}


\chapter{T-test Leakage Assessment}
\label{\detokenize{t_test:t-test-leakage-assessment}}\label{\detokenize{t_test::doc}}

\section{T-test Flow}
\label{\detokenize{t_test:t-test-flow}}
Welch’s T-test is used as a tool for leakage assessment. This guide describes using FOBOS to perform a fixed-vs-random t-test.

To perform a t-test you need to generate test-vectors that interleaves fixed and random traces.
FOBOS data acquisition is run to get the traces, then the traces are splitted into two sets and the statistical Welch’s t-test is performed.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{t_test_flow}.png}
\caption{T test flow}\label{\detokenize{t_test:id1}}\end{figure}


\section{Test vector generation}
\label{\detokenize{t_test:test-vector-generation}}
The user generates the test-vector file and a meta file that specifies which test vectors are random and which are fixed.
Fixed-vs-random t-test uses interleaved fixed and random test vectors. We can select a fixed test vector D and create a set of test vectors that  interleaves D and a randomly selected test vector. The interleaving is random.
For example the following test vector can be used to perform a t-test on an algorithm implemented on FOBOS DUT.

\fvset{hllines={, 1, 4, 6, 7,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{00}\PYG{n}{C001607000000020000000D600000CB0B1B2B3B4B} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{00}\PYG{n}{C001607000000020000000D600000C0EEB8882501} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{00}\PYG{n}{C001607000000020000000D600000CF402296C454} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{00}\PYG{n}{C001607000000020000000D600000CB0B1B2B3B4B} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{00}\PYG{n}{C001607000000020000000D600000CE919E2FC539} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{00}\PYG{n}{C001607000000020000000D600000CB0B1B2B3B4B} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{l+m+mi}{00}\PYG{n}{C001607000000020000000D600000CB0B1B2B3B4B} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}
\PYG{o}{.}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines

The corresponding fvrchoicefile specifies which traces are random ‘1’ and which are fixed ‘0’.
For example the fvrchoicefile that corresponds to the test-vectors above is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{0110100} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

See {\hyperref[\detokenize{tvgen:tvgen-label}]{\sphinxcrossref{\DUrole{std,std-ref}{Test Vector Generation}}}} for more information.


\section{Peforming a t-test}
\label{\detokenize{t_test:peforming-a-t-test}}
Once traces have been collected, scripts are used to perform the t-test.

1- Copy the \sphinxstyleemphasis{cleanTraces.py}, \sphinxstyleemphasis{splitter.py} and \sphinxstyleemphasis{t-test2.py}  scipts from fobos/software/tools/t-test to the locatation where you have the power
traces you collected.

2- Make sure you have your trace file named \sphinxstyleemphasis{powerTraces.npy} and your fvr choice file named \sphinxstyleemphasis{fvrchoicefile.txt}.
These files need to be at the same directory as the scripts copied in step 1.

3- Convert the power traces format using the read\_traces.py. Blow, you can find the parameters used with this script.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python read\PYGZus{}traces.py \PYGZhy{}h
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} readtraces.py script}
usage: read\PYGZus{}traces.py \PYG{o}{[}\PYGZhy{}h\PYG{o}{]} source\PYGZus{}file destination\PYGZus{}file num\PYGZus{}of\PYGZus{}traces

positional arguments:
source\PYGZus{}file       Traces from FOBOS dataAcquisition
destination\PYGZus{}file  .npy file that store traces as MxN Nupmy array.
num\PYGZus{}of\PYGZus{}traces     .npy file that store traces as MxN Nupmy array.

optional arguments:
\PYGZhy{}h, \PYGZhy{}\PYGZhy{}help        show this \PYG{n+nb}{help} message and \PYG{n+nb}{exit}
\end{sphinxVerbatim}

For exmple, the following command takes the powerTraces.npy file and coverts it to cleanTraces.npy and it uses only the
first 2000 traces.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{read\PYGZus{}traces}\PYG{o}{.}\PYG{n}{py} \PYG{n}{powerTraces}\PYG{o}{.}\PYG{n}{npy} \PYG{n}{cleanTraces}\PYG{o}{.}\PYG{n}{npy} \PYG{l+m+mi}{2000}
\end{sphinxVerbatim}

4-  Next, we split the cleanTraces.npy file into two trace files
\begin{itemize}
\item {} 
\sphinxstyleemphasis{traces0.npy} for the traces that came from the fixed test vector

\item {} 
\sphinxstyleemphasis{traces1.npy} for traces that came from using the random test vectors.

\end{itemize}

To do this, splitter.py needs the fvrchoicefile.txt file. It also needs to know how many traces to consider.
These are configurable parameters in the script. Here is all the parameters you can edit in splitter.py:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}Parameters}
\PYG{n}{MAX\PYGZus{}TRACE}\PYG{o}{=}\PYG{l+m+mi}{2000}
\PYG{n}{traces0File} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{traces0.npy}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{traces1File} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{traces1.npy}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{fvrFile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fvrchoicefile.txt}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{cleanTraceFile} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cleanTraces.npy}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\end{sphinxVerbatim}

Once you configure the parameters, you can run splitter using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{splitter}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

The reuslt will be 2 files called traces0.npy and traces1.npy.

5- The two files are now ready to be fed into the \sphinxstyleemphasis{t-test2.py} script to perform the t-test. Here are the parameters that this script needs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python t\PYGZhy{}test2.py \PYGZhy{}h
usage: t\PYGZhy{}test2.py [\PYGZhy{}h] trace\PYGZus{}file0 trace\PYGZus{}file1 plot\PYGZus{}file

positional arguments:
trace\PYGZus{}file0  .npy file that store traces as MxN Nupmy array
trace\PYGZus{}file1  .npy file that store traces as MxN Nupmy array
plot\PYGZus{}file    File name to store the output figure

optional arguments:
\PYGZhy{}h, \PYGZhy{}\PYGZhy{}help   show this help message and exit
\end{sphinxVerbatim}

Before running the script, also edit the plotting parameters in the script. These parameters specify the limits on the x and y axis.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Parameters \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{start\PYGZus{}ylim} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}
\PYG{n}{end\PYGZus{}ylim} \PYG{o}{=} \PYG{l+m+mi}{40}
\PYG{n}{start\PYGZus{}xlim} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{end\PYGZus{}xlim} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\end{sphinxVerbatim}

This limits the t-values to -40-40 and displays samples from 0 to 1000 on the x-axis.

Once you configure all the parameters, you can run the t-test using the following command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{n}{test2}\PYG{o}{.}\PYG{n}{py} \PYG{n}{traces0}\PYG{o}{.}\PYG{n}{npy} \PYG{n}{traces1}\PYG{o}{.}\PYG{n}{npy} \PYG{n}{result\PYGZus{}t\PYGZus{}test}\PYG{o}{.}\PYG{n}{png}
\end{sphinxVerbatim}

The output will be a file called result\_t\_test.png that shows the t-values on the y-axis and samples in the x-axis.
Here is sample file that shows a failing test and a successful one:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{aes_gcm_unprotected}.png}
\caption{T test on an unprotected AES-GCM implementation.}\label{\detokenize{t_test:id2}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{aes_gcm_protected}.png}
\caption{T test on a protected AES-GCM implementation.}\label{\detokenize{t_test:id3}}\end{figure}


\chapter{Chi-Squared Test Leakage Assessment}
\label{\detokenize{x_test:chi-squared-test-leakage-assessment}}\label{\detokenize{x_test::doc}}
The chi-squared test can be used with the t-test to assess leakage.
The chi-squared script that is provided uses ‘random’ and ‘fixed’ classes so the inputs
to the script are the same as the ones used for t-test2.py. For more information, please refer
to the T-test page.
The script is named x-test3.py and is located in fobos/software/tools/x-test.
To run the test, use the following command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python x\PYGZhy{}test3.py traces0.npy traces1.npy result\PYGZus{}x\PYGZus{}test.png
\end{sphinxVerbatim}

Where all the input files are similar to the t-test inputs.

Below, we show a chi-sqaured test that show a leakage and one that does not. In these two graphs we
choose a threshold of 10\textasciicircum{}-5 and reason that the implementation is leaking if p-values are below the threshold.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=350\sphinxpxdimen]{{x_test_ascon_unpr_s6_new}.png}
\caption{Chi-squared test on Unprotected Ascon}\label{\detokenize{x_test:id1}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=350\sphinxpxdimen]{{x_test_ascon_pr_s6_new}.png}
\caption{Chi-squared test on Protected Ascon}\label{\detokenize{x_test:id2}}\end{figure}


\chapter{API Reference}
\label{\detokenize{reference_doc:api-reference}}\label{\detokenize{reference_doc::doc}}
Here we provide documentation for important classes and methods.


\section{Basys3Ctrl Class (controller)}
\label{\detokenize{reference_doc:basys3ctrl-class-controller}}\index{fobos.Basys3Ctrl (built-in class)@\spxentry{fobos.Basys3Ctrl}\spxextra{built-in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{fobos.}}\sphinxbfcode{\sphinxupquote{Basys3Ctrl}}}{\emph{self}, \emph{port}, \emph{baudRate=115200}, \emph{dummy=False}}{}
Class to interface with Basys3 controller.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{port}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The serial port where the Basys3 board is connected(e.g /dev/ttyUSB1).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{baudRate}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Baud rate. Default is 115200.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dummy}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} When set to true, no communication with Basys3 is done.
This is to test the software only. Default is False.

\end{itemize}

\end{description}\end{quote}
\index{processData() (fobos.Basys3Ctrl method)@\spxentry{processData()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.processData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{processData}}}{\emph{self}, \emph{data}, \emph{outLen}}{}
Sends data to FOBOS hardware for processing, e.g. encryption
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The data to be processed. This is a hexadecimal string.

\item[{Rtype (str, str)}] \leavevmode
\item[{Returns}] \leavevmode
(Status (“00000000” OK \textbar{} “20000000” TIMOUT) , Result from DUT (i.e. ciphertext))

\end{description}\end{quote}

\end{fulllineitems}

\index{setOutLen() (fobos.Basys3Ctrl method)@\spxentry{setOutLen()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.setOutLen}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setOutLen}}}{\emph{self}, \emph{outLen}}{}
set DUT Expected Output Length (result length) in bytes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{outLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of output bytes to be returned by the DUT (e.g 16 for AES-128).

\item[{Rtype int}] \leavevmode
\item[{Returns}] \leavevmode
Status.

\end{description}\end{quote}

\end{fulllineitems}

\index{setTriggerWait() (fobos.Basys3Ctrl method)@\spxentry{setTriggerWait()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.setTriggerWait}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setTriggerWait}}}{\emph{self}, \emph{trigWait}}{}
Set number of trigger wait cycles
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{int}} (\sphinxstyleliteralemphasis{\sphinxupquote{trigWait}}) \textendash{} The number of DUT cycles after di\_ready goes to 0 to issue the trigger.

\item[{Return type}] \leavevmode
int

\item[{Returns}] \leavevmode
Status

\end{description}\end{quote}

\end{fulllineitems}

\index{setTriggerMode() (fobos.Basys3Ctrl method)@\spxentry{setTriggerMode()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.setTriggerMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setTriggerMode}}}{\emph{self}, \emph{trigType}}{}\pysigline{\sphinxbfcode{\sphinxupquote{Set~trigger~mode.}}}~\begin{quote}
\begin{quote}\begin{description}
\item[{param int}] \leavevmode
trigType. Possible values (TRG\_NORM = 0 \textbar{} TRG\_FULL = 1 \textbar{} TRG\_NORM\_CLK = 2 \textbar{} TRG\_FULL\_CLK = 3)

\item[{rtype}] \leavevmode
int

\item[{return}] \leavevmode
Status

\end{description}\end{quote}
\end{quote}
\index{setTimeToReset() (fobos.Basys3Ctrl method)@\spxentry{setTimeToReset()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.setTimeToReset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setTimeToReset}}}{\emph{self}, \emph{dutCycles}}{}
set number of clock cycles after di\_ready goes to 0 to reset the DUT.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{dutCycles}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of DUT cycles to reset the DUT.

\item[{Return type}] \leavevmode
int

\item[{Returns}] \leavevmode
Status.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{setTimeout() (fobos.Basys3Ctrl method)@\spxentry{setTimeout()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.setTimeout}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setTimeout}}}{\emph{self}, \emph{seconds}}{}
set number of seconds to stop waiting for DUT result.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{seconds}} (\sphinxstyleliteralemphasis{\sphinxupquote{in}}) \textendash{} Time in seconds. Range 1-40 seconds.

\item[{Return type}] \leavevmode
int

\item[{Returns}] \leavevmode
Status

\end{description}\end{quote}

\end{fulllineitems}

\index{enableTestMode() (fobos.Basys3Ctrl method)@\spxentry{enableTestMode()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.enableTestMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{enableTestMode}}}{\emph{self}}{}
Enable test mode. When this mode is enabled, the controller sends test-vectors to its internal dummy DUT.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\item[{Returns}] \leavevmode
Status

\end{description}\end{quote}

\end{fulllineitems}

\index{disableTestMode() (fobos.Basys3Ctrl method)@\spxentry{disableTestMode()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.disableTestMode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{disableTestMode}}}{\emph{self}}{}
Disable test mode. In this mode the ctrl board uses the real DUT. This is the default mode.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\item[{Returns}] \leavevmode
Status

\end{description}\end{quote}

\end{fulllineitems}

\index{forceReset() (fobos.Basys3Ctrl method)@\spxentry{forceReset()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.forceReset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{forceReset}}}{\emph{self}}{}
Reset DUT and clear current communication with DUT.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\item[{Returns}] \leavevmode
Status

\end{description}\end{quote}

\end{fulllineitems}

\index{releaseReset() (fobos.Basys3Ctrl method)@\spxentry{releaseReset()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.releaseReset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{releaseReset}}}{\emph{self}}{}
Release  DUT reset signal
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\item[{Returns}] \leavevmode
Status

\end{description}\end{quote}

\end{fulllineitems}

\index{setDUTClk() (fobos.Basys3Ctrl method)@\spxentry{setDUTClk()}\spxextra{fobos.Basys3Ctrl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:fobos.Basys3Ctrl.setDUTClk}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setDUTClk}}}{\emph{self}, \emph{clkFreqMhz}}{}
Set DUT clock frequency generated by the control board. Range is between 0.4 MHz - 100 MHz.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{clkFreqMhz}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The DUT clock frequency in Mhz.

\item[{Return type}] \leavevmode
int

\item[{Returns}] \leavevmode
Status

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Scope (Picoscope Class)}
\label{\detokenize{reference_doc:scope-picoscope-class}}\index{Picoscope (built-in class)@\spxentry{Picoscope}\spxextra{built-in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Picoscope}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Picoscope}}}{\emph{self}, \emph{sampleResolution=8}, \emph{preTriggerSamples=0}, \emph{postTriggerSamples=1000}}{}
A class to interface with the Picoscope oscilloscope.
\index{\_\_init\_\_() (Picoscope method)@\spxentry{\_\_init\_\_()}\spxextra{Picoscope method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Picoscope.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{self}, \emph{sampleResolution=8}, \emph{preTriggerSamples=0}, \emph{postTriggerSamples=1000}}{}
Open oscilloscope
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sampleResolution}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of bits used to represent each sample. Possible values 8, 12, 14, 15 and 16.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{preTriggerSamples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of samples before the trigger to return to the user.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{postTriggerSamples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of samples after the trigger to return to the user.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setChannel() (Picoscope method)@\spxentry{setChannel()}\spxextra{Picoscope method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Picoscope.setChannel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setChannel}}}{\emph{self}, \emph{channelName='CHANNEL\_A'}, \emph{coupling='DC'}, \emph{rangemv='1V'}}{}
Configure voltage range and coupling for a channel.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channelName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of the oscilloscope channel (CHANNEL\_A \textbar{} CHANNELB).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coupling}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Select DC/AC coupling (DC \textbar{} AC)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rangemv}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The voltage range for the selected channel (10mV\textbar{}20mV\textbar{}50mV\textbar{}100mV\textbar{}200mV\textbar{}500mV\textbar{}1V\textbar{}2V\textbar{}5V\textbar{}10V\textbar{}20V)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setSamplingInterval() (Picoscope method)@\spxentry{setSamplingInterval()}\spxextra{Picoscope method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Picoscope.setSamplingInterval}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setSamplingInterval}}}{\emph{self}, \emph{samplingIntervalns}}{}
Sets the sampling interval (time between samples T) in nano seconds. Sampling rate = 1/T.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{samplingInterval}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Sampling interval (time between samples T) in nano seconds. Sampling rate = 1/T.

\end{description}\end{quote}

\end{fulllineitems}

\index{setTrigger() (Picoscope method)@\spxentry{setTrigger()}\spxextra{Picoscope method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Picoscope.setTrigger}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setTrigger}}}{\emph{self}, \emph{channelName= 'CHANNEL\_A'}, \emph{thresholdmv = 500}, \emph{direction = 'RISING\_EDGE'}, \emph{autoTriggerDelay = 2000}}{}
Configure trigger channel.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{channelName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The channel to use as a trigger channel (CHANNEL\_A \textbar{} CHANNELB \textbar{} EXTERNAL).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{thresholdmv}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The minimum level of voltage to assert a trigger.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{direction}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The trigger signal direction (RISING\_EDGE\textbar{} FALLING\_EDGE).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{autoTriggerDelay}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Time in milliseconds after which auto trigger occurs (i.e start storing data even if no valid trigger received).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setDataBuffers() (Picoscope method)@\spxentry{setDataBuffers()}\spxextra{Picoscope method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Picoscope.setDataBuffers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setDataBuffers}}}{}{}
Allocates memory buffers to store oscilloscope data.

\end{fulllineitems}


\end{fulllineitems}



\section{ProjectManager Class}
\label{\detokenize{reference_doc:projectmanager-class}}\index{ProjectManager (built-in class)@\spxentry{ProjectManager}\spxextra{built-in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:ProjectManager}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{ProjectManager}}}
A class to facilitate organizing and saving results files/data files in automatically created directories. For example, when new capture is performed a directory named attempt-{[}number{]} will be created in the capture directory.
\index{setWorkSpaceDir() (ProjectManager method)@\spxentry{setWorkSpaceDir()}\spxextra{ProjectManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:ProjectManager.setWorkSpaceDir}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setWorkSpaceDir}}}{\emph{self}, \emph{workSpaceDir}}{}
Sets the directory where all data will be saved.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{workSpaceDir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Workspace directory path.

\end{description}\end{quote}

\end{fulllineitems}

\index{setProjName() (ProjectManager method)@\spxentry{setProjName()}\spxextra{ProjectManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:ProjectManager.setProjName}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setProjName}}}{}{}
Sets the project name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{projectName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Project name. A directory will be created in the workspace with the project name.

\end{description}\end{quote}

\end{fulllineitems}

\index{getProjDir() (ProjectManager method)@\spxentry{getProjDir()}\spxextra{ProjectManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:ProjectManager.getProjDir}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getProjDir}}}{}{}
Gets the project directory path.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Full project directory path.

\end{description}\end{quote}

\end{fulllineitems}

\index{getCaptureDir() (ProjectManager method)@\spxentry{getCaptureDir()}\spxextra{ProjectManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:ProjectManager.getCaptureDir}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getCaptureDir}}}{}{}
Creates and returns the path of a new directory created in \sphinxstyleemphasis{worksapce/projectName/capture/} the folder will be named \sphinxstyleemphasis{attempt-(number)} for uniqueness.

\end{fulllineitems}


\end{fulllineitems}



\section{Nexy3DUT Class}
\label{\detokenize{reference_doc:nexy3dut-class}}\index{Nexys3DUT (built-in class)@\spxentry{Nexys3DUT}\spxextra{built-in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Nexys3DUT}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Nexys3DUT}}}
A class to program Digilent Nexy3 DUT. This class requires that Digilent Adept command line tools (djtgcfg command) is installed.
\index{setBitFile() (Nexys3DUT method)@\spxentry{setBitFile()}\spxextra{Nexys3DUT method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Nexys3DUT.setBitFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setBitFile}}}{\emph{bitFile}}{}
Sets the bit file name used to program the DUT FPGA.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{bitFile}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Full path of the .bit file to program the FPGA.

\end{description}\end{quote}

\end{fulllineitems}

\index{program() (Nexys3DUT method)@\spxentry{program()}\spxextra{Nexys3DUT method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:Nexys3DUT.program}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{program}}}{}{}
Programs the FPGA using the bit file specified using he setBitFile method.

\end{fulllineitems}


\end{fulllineitems}



\section{CPA Class}
\label{\detokenize{reference_doc:cpa-class}}\index{CPA (built-in class)@\spxentry{CPA}\spxextra{built-in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:CPA}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CPA}}}
A class to perform Correlation Power Analysis.
\index{doCPA() (CPA method)@\spxentry{doCPA()}\spxextra{CPA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:CPA.doCPA}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{doCPA}}}{\emph{self}, \emph{measuredPower}, \emph{hypotheticalPower}, \emph{numTraces}, \emph{analysisDir}, \emph{MTDStride}}{}
Perform CPA.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{measuredPower}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy\_array}}) \textendash{} The power measure using the oscilloscope.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hypotheticalPower}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy\_array}}) \textendash{} The hypotheticalPower estimated using the power model.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{numTraces}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of traces in to be analyzed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{analysisDir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Full path of the directory to store analysis results.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{MTDStride}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of traces to add in each step when plotting the MTD graph.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{DataGenerator Class}
\label{\detokenize{reference_doc:datagenerator-class}}\index{DataGenerator (built-in class)@\spxentry{DataGenerator}\spxextra{built-in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:DataGenerator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{DataGenerator}}}
A class to generate FOBOS-ready test vectors.
\begin{quote}
\index{randTVFile() (DataGenerator method)@\spxentry{randTVFile()}\spxextra{DataGenerator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:DataGenerator.randTVFile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randTVFile}}}{\emph{self}, \emph{pdiLen}, \emph{sdiLen}, \emph{rdiLen}, \emph{outLen}, \emph{fileName}, \emph{numTVs}}{}
Generate a FOBOS-ready test-vector file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdiLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The lenght of PDI data (e.g plaintext) in bytes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sdiLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The lenght of SDI data (e.g secret key) in bytes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rdiLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The lenght of RDI data (random data) in bytes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The lenght of expected output (e.g ciphertext) in bytes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of the file to store the testvectors.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{randTestVector() (DataGenerator method)@\spxentry{randTestVector()}\spxextra{DataGenerator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference_doc:DataGenerator.randTestVector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randTestVector}}}{\emph{self}, \emph{pdiLen}, \emph{sdiLen}, \emph{rdiLen}, \emph{outLen}}{}
Generate a single FOBOS-ready test-vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdiLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The lenght of PDI data (e.g plaintext) in bytes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sdiLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The lenght of SDI data (e.g secret key) in bytes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rdiLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The lenght of RDI data (random data) in bytes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{outLen}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The lenght of expected output (e.g ciphertext) in bytes.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\end{quote}

\end{fulllineitems}



\chapter{License}
\label{\detokenize{license:license}}\label{\detokenize{license::doc}}
Apache License
Version 2.0, January 2004
\sphinxurl{http://www.apache.org/licenses/}
\begin{quote}

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Definitions.

“License” shall mean the terms and conditions for use, reproduction,
and distribution as defined by Sections 1 through 9 of this document.

“Licensor” shall mean the copyright owner or entity authorized by
the copyright owner that is granting the License.

“Legal Entity” shall mean the union of the acting entity and all
other entities that control, are controlled by, or are under common
control with that entity. For the purposes of this definition,
“control” means (i) the power, direct or indirect, to cause the
direction or management of such entity, whether by contract or
otherwise, or (ii) ownership of fifty percent (50\%) or more of the
outstanding shares, or (iii) beneficial ownership of such entity.

“You” (or “Your”) shall mean an individual or Legal Entity
exercising permissions granted by this License.

“Source” form shall mean the preferred form for making modifications,
including but not limited to software source code, documentation
source, and configuration files.

“Object” form shall mean any form resulting from mechanical
transformation or translation of a Source form, including but
not limited to compiled object code, generated documentation,
and conversions to other media types.

“Work” shall mean the work of authorship, whether in Source or
Object form, made available under the License, as indicated by a
copyright notice that is included in or attached to the work
(an example is provided in the Appendix below).

“Derivative Works” shall mean any work, whether in Source or Object
form, that is based on (or derived from) the Work and for which the
editorial revisions, annotations, elaborations, or other modifications
represent, as a whole, an original work of authorship. For the purposes
of this License, Derivative Works shall not include works that remain
separable from, or merely link (or bind by name) to the interfaces of,
the Work and Derivative Works thereof.

“Contribution” shall mean any work of authorship, including
the original version of the Work and any modifications or additions
to that Work or Derivative Works thereof, that is intentionally
submitted to Licensor for inclusion in the Work by the copyright owner
or by an individual or Legal Entity authorized to submit on behalf of
the copyright owner. For the purposes of this definition, “submitted”
means any form of electronic, verbal, or written communication sent
to the Licensor or its representatives, including but not limited to
communication on electronic mailing lists, source code control systems,
and issue tracking systems that are managed by, or on behalf of, the
Licensor for the purpose of discussing and improving the Work, but
excluding communication that is conspicuously marked or otherwise
designated in writing by the copyright owner as “Not a Contribution.”

“Contributor” shall mean Licensor and any individual or Legal Entity
on behalf of whom a Contribution has been received by Licensor and
subsequently incorporated within the Work.

\item {} 
Grant of Copyright License. Subject to the terms and conditions of
this License, each Contributor hereby grants to You a perpetual,
worldwide, non-exclusive, no-charge, royalty-free, irrevocable
copyright license to reproduce, prepare Derivative Works of,
publicly display, publicly perform, sublicense, and distribute the
Work and such Derivative Works in Source or Object form.

\item {} 
Grant of Patent License. Subject to the terms and conditions of
this License, each Contributor hereby grants to You a perpetual,
worldwide, non-exclusive, no-charge, royalty-free, irrevocable
(except as stated in this section) patent license to make, have made,
use, offer to sell, sell, import, and otherwise transfer the Work,
where such license applies only to those patent claims licensable
by such Contributor that are necessarily infringed by their
Contribution(s) alone or by combination of their Contribution(s)
with the Work to which such Contribution(s) was submitted. If You
institute patent litigation against any entity (including a
cross-claim or counterclaim in a lawsuit) alleging that the Work
or a Contribution incorporated within the Work constitutes direct
or contributory patent infringement, then any patent licenses
granted to You under this License for that Work shall terminate
as of the date such litigation is filed.

\item {} 
Redistribution. You may reproduce and distribute copies of the
Work or Derivative Works thereof in any medium, with or without
modifications, and in Source or Object form, provided that You
meet the following conditions:
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{(}{)}%
\item {} 
You must give any other recipients of the Work or
Derivative Works a copy of this License; and

\item {} 
You must cause any modified files to carry prominent notices
stating that You changed the files; and

\item {} 
You must retain, in the Source form of any Derivative Works
that You distribute, all copyright, patent, trademark, and
attribution notices from the Source form of the Work,
excluding those notices that do not pertain to any part of
the Derivative Works; and

\item {} 
If the Work includes a “NOTICE” text file as part of its
distribution, then any Derivative Works that You distribute must
include a readable copy of the attribution notices contained
within such NOTICE file, excluding those notices that do not
pertain to any part of the Derivative Works, in at least one
of the following places: within a NOTICE text file distributed
as part of the Derivative Works; within the Source form or
documentation, if provided along with the Derivative Works; or,
within a display generated by the Derivative Works, if and
wherever such third-party notices normally appear. The contents
of the NOTICE file are for informational purposes only and
do not modify the License. You may add Your own attribution
notices within Derivative Works that You distribute, alongside
or as an addendum to the NOTICE text from the Work, provided
that such additional attribution notices cannot be construed
as modifying the License.

\end{enumerate}

You may add Your own copyright statement to Your modifications and
may provide additional or different license terms and conditions
for use, reproduction, or distribution of Your modifications, or
for any such Derivative Works as a whole, provided Your use,
reproduction, and distribution of the Work otherwise complies with
the conditions stated in this License.

\item {} 
Submission of Contributions. Unless You explicitly state otherwise,
any Contribution intentionally submitted for inclusion in the Work
by You to the Licensor shall be under the terms and conditions of
this License, without any additional terms or conditions.
Notwithstanding the above, nothing herein shall supersede or modify
the terms of any separate license agreement you may have executed
with Licensor regarding such Contributions.

\item {} 
Trademarks. This License does not grant permission to use the trade
names, trademarks, service marks, or product names of the Licensor,
except as required for reasonable and customary use in describing the
origin of the Work and reproducing the content of the NOTICE file.

\item {} 
Disclaimer of Warranty. Unless required by applicable law or
agreed to in writing, Licensor provides the Work (and each
Contributor provides its Contributions) on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied, including, without limitation, any warranties or conditions
of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
PARTICULAR PURPOSE. You are solely responsible for determining the
appropriateness of using or redistributing the Work and assume any
risks associated with Your exercise of permissions under this License.

\item {} 
Limitation of Liability. In no event and under no legal theory,
whether in tort (including negligence), contract, or otherwise,
unless required by applicable law (such as deliberate and grossly
negligent acts) or agreed to in writing, shall any Contributor be
liable to You for damages, including any direct, indirect, special,
incidental, or consequential damages of any character arising as a
result of this License or out of the use or inability to use the
Work (including but not limited to damages for loss of goodwill,
work stoppage, computer failure or malfunction, or any and all
other commercial damages or losses), even if such Contributor
has been advised of the possibility of such damages.

\item {} 
Accepting Warranty or Additional Liability. While redistributing
the Work or Derivative Works thereof, You may choose to offer,
and charge a fee for, acceptance of support, warranty, indemnity,
or other liability obligations and/or rights consistent with this
License. However, in accepting such obligations, You may act only
on Your own behalf and on Your sole responsibility, not on behalf
of any other Contributor, and only if You agree to indemnify,
defend, and hold each Contributor harmless for any liability
incurred by, or claims asserted against, such Contributor by reason
of your accepting any such warranty or additional liability.

\end{enumerate}

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.
\begin{quote}

To apply the Apache License to your work, attach the following
boilerplate notice, with the fields enclosed by brackets “{[}{]}”
replaced with your own identifying information. (Don’t include
the brackets!)  The text should be enclosed in the appropriate
comment syntax for the file format. We also recommend that a
file or class name and description of purpose be included on the
same “printed page” as the copyright notice for easier
identification within third-party archives.
\end{quote}

Copyright {[}yyyy{]} {[}name of copyright owner{]}

Licensed under the Apache License, Version 2.0 (the “License”);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
\begin{quote}

\sphinxurl{http://www.apache.org/licenses/LICENSE-2.0}
\end{quote}

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
\end{quote}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}